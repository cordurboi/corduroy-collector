"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@metamask+eth-sig-util@7.0.2";
exports.ids = ["vendor-chunks/@metamask+eth-sig-util@7.0.2"];
exports.modules = {

/***/ "(ssr)/../../node_modules/.pnpm/@metamask+eth-sig-util@7.0.2/node_modules/@metamask/eth-sig-util/dist/encryption.js":
/*!********************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/@metamask+eth-sig-util@7.0.2/node_modules/@metamask/eth-sig-util/dist/encryption.js ***!
  \********************************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.getEncryptionPublicKey = exports.decryptSafely = exports.decrypt = exports.encryptSafely = exports.encrypt = void 0;\nconst base_1 = __webpack_require__(/*! @scure/base */ \"(ssr)/../../node_modules/.pnpm/@scure+base@1.1.9/node_modules/@scure/base/lib/index.js\");\nconst nacl = __importStar(__webpack_require__(/*! tweetnacl */ \"(ssr)/../../node_modules/.pnpm/tweetnacl@1.0.3/node_modules/tweetnacl/nacl-fast.js\"));\nconst utils_1 = __webpack_require__(/*! ./utils */ \"(ssr)/../../node_modules/.pnpm/@metamask+eth-sig-util@7.0.2/node_modules/@metamask/eth-sig-util/dist/utils.js\");\n/**\n * Encrypt a message.\n *\n * @param options - The encryption options.\n * @param options.publicKey - The public key of the message recipient.\n * @param options.data - The message data.\n * @param options.version - The type of encryption to use.\n * @returns The encrypted data.\n */\nfunction encrypt({ publicKey, data, version, }) {\n    if ((0, utils_1.isNullish)(publicKey)) {\n        throw new Error('Missing publicKey parameter');\n    }\n    else if ((0, utils_1.isNullish)(data)) {\n        throw new Error('Missing data parameter');\n    }\n    else if ((0, utils_1.isNullish)(version)) {\n        throw new Error('Missing version parameter');\n    }\n    switch (version) {\n        case 'x25519-xsalsa20-poly1305': {\n            if (typeof data !== 'string') {\n                throw new Error('Message data must be given as a string');\n            }\n            // generate ephemeral keypair\n            const ephemeralKeyPair = nacl.box.keyPair();\n            // assemble encryption parameters - from string to UInt8\n            let pubKeyUInt8Array;\n            try {\n                pubKeyUInt8Array = base_1.base64.decode(publicKey);\n            }\n            catch (err) {\n                throw new Error('Bad public key');\n            }\n            const msgParamsUInt8Array = base_1.utf8.decode(data);\n            const nonce = nacl.randomBytes(nacl.box.nonceLength);\n            // encrypt\n            const encryptedMessage = nacl.box(msgParamsUInt8Array, nonce, pubKeyUInt8Array, ephemeralKeyPair.secretKey);\n            // handle encrypted data\n            const output = {\n                version: 'x25519-xsalsa20-poly1305',\n                nonce: base_1.base64.encode(nonce),\n                ephemPublicKey: base_1.base64.encode(ephemeralKeyPair.publicKey),\n                ciphertext: base_1.base64.encode(encryptedMessage),\n            };\n            // return encrypted msg data\n            return output;\n        }\n        default:\n            throw new Error('Encryption type/version not supported');\n    }\n}\nexports.encrypt = encrypt;\n/**\n * Encrypt a message in a way that obscures the message length.\n *\n * The message is padded to a multiple of 2048 before being encrypted so that the length of the\n * resulting encrypted message can't be used to guess the exact length of the original message.\n *\n * @param options - The encryption options.\n * @param options.publicKey - The public key of the message recipient.\n * @param options.data - The message data.\n * @param options.version - The type of encryption to use.\n * @returns The encrypted data.\n */\nfunction encryptSafely({ publicKey, data, version, }) {\n    if ((0, utils_1.isNullish)(publicKey)) {\n        throw new Error('Missing publicKey parameter');\n    }\n    else if ((0, utils_1.isNullish)(data)) {\n        throw new Error('Missing data parameter');\n    }\n    else if ((0, utils_1.isNullish)(version)) {\n        throw new Error('Missing version parameter');\n    }\n    const DEFAULT_PADDING_LENGTH = 2 ** 11;\n    const NACL_EXTRA_BYTES = 16;\n    if (typeof data === 'object' && data && 'toJSON' in data) {\n        // remove toJSON attack vector\n        // TODO, check all possible children\n        throw new Error('Cannot encrypt with toJSON property.  Please remove toJSON property');\n    }\n    // add padding\n    const dataWithPadding = {\n        data,\n        padding: '',\n    };\n    // calculate padding\n    const dataLength = Buffer.byteLength(JSON.stringify(dataWithPadding), 'utf-8');\n    const modVal = dataLength % DEFAULT_PADDING_LENGTH;\n    let padLength = 0;\n    // Only pad if necessary\n    if (modVal > 0) {\n        padLength = DEFAULT_PADDING_LENGTH - modVal - NACL_EXTRA_BYTES; // nacl extra bytes\n    }\n    dataWithPadding.padding = '0'.repeat(padLength);\n    const paddedMessage = JSON.stringify(dataWithPadding);\n    return encrypt({ publicKey, data: paddedMessage, version });\n}\nexports.encryptSafely = encryptSafely;\n/**\n * Decrypt a message.\n *\n * @param options - The decryption options.\n * @param options.encryptedData - The encrypted data.\n * @param options.privateKey - The private key to decrypt with.\n * @returns The decrypted message.\n */\nfunction decrypt({ encryptedData, privateKey, }) {\n    if ((0, utils_1.isNullish)(encryptedData)) {\n        throw new Error('Missing encryptedData parameter');\n    }\n    else if ((0, utils_1.isNullish)(privateKey)) {\n        throw new Error('Missing privateKey parameter');\n    }\n    switch (encryptedData.version) {\n        case 'x25519-xsalsa20-poly1305': {\n            const receiverPrivateKeyUint8Array = Buffer.from(privateKey, 'hex');\n            const receiverEncryptionPrivateKey = nacl.box.keyPair.fromSecretKey(receiverPrivateKeyUint8Array).secretKey;\n            // assemble decryption parameters\n            const nonce = base_1.base64.decode(encryptedData.nonce);\n            const ciphertext = base_1.base64.decode(encryptedData.ciphertext);\n            const ephemPublicKey = base_1.base64.decode(encryptedData.ephemPublicKey);\n            // decrypt\n            const decryptedMessage = nacl.box.open(ciphertext, nonce, ephemPublicKey, receiverEncryptionPrivateKey);\n            // return decrypted msg data\n            try {\n                if (!decryptedMessage) {\n                    throw new Error();\n                }\n                const output = base_1.utf8.encode(decryptedMessage);\n                // TODO: This is probably extraneous but was kept to minimize changes during refactor\n                if (!output) {\n                    throw new Error();\n                }\n                return output;\n            }\n            catch (err) {\n                if (err && typeof err.message === 'string' && err.message.length) {\n                    throw new Error(`Decryption failed: ${err.message}`);\n                }\n                throw new Error(`Decryption failed.`);\n            }\n        }\n        default:\n            throw new Error('Encryption type/version not supported.');\n    }\n}\nexports.decrypt = decrypt;\n/**\n * Decrypt a message that has been encrypted using `encryptSafely`.\n *\n * @param options - The decryption options.\n * @param options.encryptedData - The encrypted data.\n * @param options.privateKey - The private key to decrypt with.\n * @returns The decrypted message.\n */\nfunction decryptSafely({ encryptedData, privateKey, }) {\n    if ((0, utils_1.isNullish)(encryptedData)) {\n        throw new Error('Missing encryptedData parameter');\n    }\n    else if ((0, utils_1.isNullish)(privateKey)) {\n        throw new Error('Missing privateKey parameter');\n    }\n    const dataWithPadding = JSON.parse(decrypt({ encryptedData, privateKey }));\n    return dataWithPadding.data;\n}\nexports.decryptSafely = decryptSafely;\n/**\n * Get the encryption public key for the given key.\n *\n * @param privateKey - The private key to generate the encryption public key with.\n * @returns The encryption public key.\n */\nfunction getEncryptionPublicKey(privateKey) {\n    const privateKeyUint8Array = Buffer.from(privateKey, 'hex');\n    const encryptionPublicKey = nacl.box.keyPair.fromSecretKey(privateKeyUint8Array).publicKey;\n    return base_1.base64.encode(encryptionPublicKey);\n}\nexports.getEncryptionPublicKey = getEncryptionPublicKey;\n//# sourceMappingURL=encryption.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BtZXRhbWFzaytldGgtc2lnLXV0aWxANy4wLjIvbm9kZV9tb2R1bGVzL0BtZXRhbWFzay9ldGgtc2lnLXV0aWwvZGlzdC9lbmNyeXB0aW9uLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG9DQUFvQztBQUNuRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSwwQ0FBMEMsNEJBQTRCO0FBQ3RFLENBQUM7QUFDRDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCw4QkFBOEIsR0FBRyxxQkFBcUIsR0FBRyxlQUFlLEdBQUcscUJBQXFCLEdBQUcsZUFBZTtBQUNsSCxlQUFlLG1CQUFPLENBQUMsMkdBQWE7QUFDcEMsMEJBQTBCLG1CQUFPLENBQUMscUdBQVc7QUFDN0MsZ0JBQWdCLG1CQUFPLENBQUMsOEhBQVM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLDJCQUEyQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLDJCQUEyQjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3RUFBd0U7QUFDeEU7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLHlDQUF5QztBQUM5RDtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLDRCQUE0QjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQsWUFBWTtBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsNEJBQTRCO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCwyQkFBMkI7QUFDNUU7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQGNvbGxlY3RpYmxlL3dlYi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vQG1ldGFtYXNrK2V0aC1zaWctdXRpbEA3LjAuMi9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL2V0aC1zaWctdXRpbC9kaXN0L2VuY3J5cHRpb24uanM/NjQ3NyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcbiAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX3NldE1vZHVsZURlZmF1bHQpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHYgfSk7XG59KSA6IGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBvW1wiZGVmYXVsdFwiXSA9IHY7XG59KTtcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChrICE9PSBcImRlZmF1bHRcIiAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgX19jcmVhdGVCaW5kaW5nKHJlc3VsdCwgbW9kLCBrKTtcbiAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5nZXRFbmNyeXB0aW9uUHVibGljS2V5ID0gZXhwb3J0cy5kZWNyeXB0U2FmZWx5ID0gZXhwb3J0cy5kZWNyeXB0ID0gZXhwb3J0cy5lbmNyeXB0U2FmZWx5ID0gZXhwb3J0cy5lbmNyeXB0ID0gdm9pZCAwO1xuY29uc3QgYmFzZV8xID0gcmVxdWlyZShcIkBzY3VyZS9iYXNlXCIpO1xuY29uc3QgbmFjbCA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwidHdlZXRuYWNsXCIpKTtcbmNvbnN0IHV0aWxzXzEgPSByZXF1aXJlKFwiLi91dGlsc1wiKTtcbi8qKlxuICogRW5jcnlwdCBhIG1lc3NhZ2UuXG4gKlxuICogQHBhcmFtIG9wdGlvbnMgLSBUaGUgZW5jcnlwdGlvbiBvcHRpb25zLlxuICogQHBhcmFtIG9wdGlvbnMucHVibGljS2V5IC0gVGhlIHB1YmxpYyBrZXkgb2YgdGhlIG1lc3NhZ2UgcmVjaXBpZW50LlxuICogQHBhcmFtIG9wdGlvbnMuZGF0YSAtIFRoZSBtZXNzYWdlIGRhdGEuXG4gKiBAcGFyYW0gb3B0aW9ucy52ZXJzaW9uIC0gVGhlIHR5cGUgb2YgZW5jcnlwdGlvbiB0byB1c2UuXG4gKiBAcmV0dXJucyBUaGUgZW5jcnlwdGVkIGRhdGEuXG4gKi9cbmZ1bmN0aW9uIGVuY3J5cHQoeyBwdWJsaWNLZXksIGRhdGEsIHZlcnNpb24sIH0pIHtcbiAgICBpZiAoKDAsIHV0aWxzXzEuaXNOdWxsaXNoKShwdWJsaWNLZXkpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTWlzc2luZyBwdWJsaWNLZXkgcGFyYW1ldGVyJyk7XG4gICAgfVxuICAgIGVsc2UgaWYgKCgwLCB1dGlsc18xLmlzTnVsbGlzaCkoZGF0YSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNaXNzaW5nIGRhdGEgcGFyYW1ldGVyJyk7XG4gICAgfVxuICAgIGVsc2UgaWYgKCgwLCB1dGlsc18xLmlzTnVsbGlzaCkodmVyc2lvbikpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNaXNzaW5nIHZlcnNpb24gcGFyYW1ldGVyJyk7XG4gICAgfVxuICAgIHN3aXRjaCAodmVyc2lvbikge1xuICAgICAgICBjYXNlICd4MjU1MTkteHNhbHNhMjAtcG9seTEzMDUnOiB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGRhdGEgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNZXNzYWdlIGRhdGEgbXVzdCBiZSBnaXZlbiBhcyBhIHN0cmluZycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gZ2VuZXJhdGUgZXBoZW1lcmFsIGtleXBhaXJcbiAgICAgICAgICAgIGNvbnN0IGVwaGVtZXJhbEtleVBhaXIgPSBuYWNsLmJveC5rZXlQYWlyKCk7XG4gICAgICAgICAgICAvLyBhc3NlbWJsZSBlbmNyeXB0aW9uIHBhcmFtZXRlcnMgLSBmcm9tIHN0cmluZyB0byBVSW50OFxuICAgICAgICAgICAgbGV0IHB1YktleVVJbnQ4QXJyYXk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHB1YktleVVJbnQ4QXJyYXkgPSBiYXNlXzEuYmFzZTY0LmRlY29kZShwdWJsaWNLZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQmFkIHB1YmxpYyBrZXknKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IG1zZ1BhcmFtc1VJbnQ4QXJyYXkgPSBiYXNlXzEudXRmOC5kZWNvZGUoZGF0YSk7XG4gICAgICAgICAgICBjb25zdCBub25jZSA9IG5hY2wucmFuZG9tQnl0ZXMobmFjbC5ib3gubm9uY2VMZW5ndGgpO1xuICAgICAgICAgICAgLy8gZW5jcnlwdFxuICAgICAgICAgICAgY29uc3QgZW5jcnlwdGVkTWVzc2FnZSA9IG5hY2wuYm94KG1zZ1BhcmFtc1VJbnQ4QXJyYXksIG5vbmNlLCBwdWJLZXlVSW50OEFycmF5LCBlcGhlbWVyYWxLZXlQYWlyLnNlY3JldEtleSk7XG4gICAgICAgICAgICAvLyBoYW5kbGUgZW5jcnlwdGVkIGRhdGFcbiAgICAgICAgICAgIGNvbnN0IG91dHB1dCA9IHtcbiAgICAgICAgICAgICAgICB2ZXJzaW9uOiAneDI1NTE5LXhzYWxzYTIwLXBvbHkxMzA1JyxcbiAgICAgICAgICAgICAgICBub25jZTogYmFzZV8xLmJhc2U2NC5lbmNvZGUobm9uY2UpLFxuICAgICAgICAgICAgICAgIGVwaGVtUHVibGljS2V5OiBiYXNlXzEuYmFzZTY0LmVuY29kZShlcGhlbWVyYWxLZXlQYWlyLnB1YmxpY0tleSksXG4gICAgICAgICAgICAgICAgY2lwaGVydGV4dDogYmFzZV8xLmJhc2U2NC5lbmNvZGUoZW5jcnlwdGVkTWVzc2FnZSksXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgLy8gcmV0dXJuIGVuY3J5cHRlZCBtc2cgZGF0YVxuICAgICAgICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICAgICAgfVxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFbmNyeXB0aW9uIHR5cGUvdmVyc2lvbiBub3Qgc3VwcG9ydGVkJyk7XG4gICAgfVxufVxuZXhwb3J0cy5lbmNyeXB0ID0gZW5jcnlwdDtcbi8qKlxuICogRW5jcnlwdCBhIG1lc3NhZ2UgaW4gYSB3YXkgdGhhdCBvYnNjdXJlcyB0aGUgbWVzc2FnZSBsZW5ndGguXG4gKlxuICogVGhlIG1lc3NhZ2UgaXMgcGFkZGVkIHRvIGEgbXVsdGlwbGUgb2YgMjA0OCBiZWZvcmUgYmVpbmcgZW5jcnlwdGVkIHNvIHRoYXQgdGhlIGxlbmd0aCBvZiB0aGVcbiAqIHJlc3VsdGluZyBlbmNyeXB0ZWQgbWVzc2FnZSBjYW4ndCBiZSB1c2VkIHRvIGd1ZXNzIHRoZSBleGFjdCBsZW5ndGggb2YgdGhlIG9yaWdpbmFsIG1lc3NhZ2UuXG4gKlxuICogQHBhcmFtIG9wdGlvbnMgLSBUaGUgZW5jcnlwdGlvbiBvcHRpb25zLlxuICogQHBhcmFtIG9wdGlvbnMucHVibGljS2V5IC0gVGhlIHB1YmxpYyBrZXkgb2YgdGhlIG1lc3NhZ2UgcmVjaXBpZW50LlxuICogQHBhcmFtIG9wdGlvbnMuZGF0YSAtIFRoZSBtZXNzYWdlIGRhdGEuXG4gKiBAcGFyYW0gb3B0aW9ucy52ZXJzaW9uIC0gVGhlIHR5cGUgb2YgZW5jcnlwdGlvbiB0byB1c2UuXG4gKiBAcmV0dXJucyBUaGUgZW5jcnlwdGVkIGRhdGEuXG4gKi9cbmZ1bmN0aW9uIGVuY3J5cHRTYWZlbHkoeyBwdWJsaWNLZXksIGRhdGEsIHZlcnNpb24sIH0pIHtcbiAgICBpZiAoKDAsIHV0aWxzXzEuaXNOdWxsaXNoKShwdWJsaWNLZXkpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTWlzc2luZyBwdWJsaWNLZXkgcGFyYW1ldGVyJyk7XG4gICAgfVxuICAgIGVsc2UgaWYgKCgwLCB1dGlsc18xLmlzTnVsbGlzaCkoZGF0YSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNaXNzaW5nIGRhdGEgcGFyYW1ldGVyJyk7XG4gICAgfVxuICAgIGVsc2UgaWYgKCgwLCB1dGlsc18xLmlzTnVsbGlzaCkodmVyc2lvbikpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNaXNzaW5nIHZlcnNpb24gcGFyYW1ldGVyJyk7XG4gICAgfVxuICAgIGNvbnN0IERFRkFVTFRfUEFERElOR19MRU5HVEggPSAyICoqIDExO1xuICAgIGNvbnN0IE5BQ0xfRVhUUkFfQllURVMgPSAxNjtcbiAgICBpZiAodHlwZW9mIGRhdGEgPT09ICdvYmplY3QnICYmIGRhdGEgJiYgJ3RvSlNPTicgaW4gZGF0YSkge1xuICAgICAgICAvLyByZW1vdmUgdG9KU09OIGF0dGFjayB2ZWN0b3JcbiAgICAgICAgLy8gVE9ETywgY2hlY2sgYWxsIHBvc3NpYmxlIGNoaWxkcmVuXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGVuY3J5cHQgd2l0aCB0b0pTT04gcHJvcGVydHkuICBQbGVhc2UgcmVtb3ZlIHRvSlNPTiBwcm9wZXJ0eScpO1xuICAgIH1cbiAgICAvLyBhZGQgcGFkZGluZ1xuICAgIGNvbnN0IGRhdGFXaXRoUGFkZGluZyA9IHtcbiAgICAgICAgZGF0YSxcbiAgICAgICAgcGFkZGluZzogJycsXG4gICAgfTtcbiAgICAvLyBjYWxjdWxhdGUgcGFkZGluZ1xuICAgIGNvbnN0IGRhdGFMZW5ndGggPSBCdWZmZXIuYnl0ZUxlbmd0aChKU09OLnN0cmluZ2lmeShkYXRhV2l0aFBhZGRpbmcpLCAndXRmLTgnKTtcbiAgICBjb25zdCBtb2RWYWwgPSBkYXRhTGVuZ3RoICUgREVGQVVMVF9QQURESU5HX0xFTkdUSDtcbiAgICBsZXQgcGFkTGVuZ3RoID0gMDtcbiAgICAvLyBPbmx5IHBhZCBpZiBuZWNlc3NhcnlcbiAgICBpZiAobW9kVmFsID4gMCkge1xuICAgICAgICBwYWRMZW5ndGggPSBERUZBVUxUX1BBRERJTkdfTEVOR1RIIC0gbW9kVmFsIC0gTkFDTF9FWFRSQV9CWVRFUzsgLy8gbmFjbCBleHRyYSBieXRlc1xuICAgIH1cbiAgICBkYXRhV2l0aFBhZGRpbmcucGFkZGluZyA9ICcwJy5yZXBlYXQocGFkTGVuZ3RoKTtcbiAgICBjb25zdCBwYWRkZWRNZXNzYWdlID0gSlNPTi5zdHJpbmdpZnkoZGF0YVdpdGhQYWRkaW5nKTtcbiAgICByZXR1cm4gZW5jcnlwdCh7IHB1YmxpY0tleSwgZGF0YTogcGFkZGVkTWVzc2FnZSwgdmVyc2lvbiB9KTtcbn1cbmV4cG9ydHMuZW5jcnlwdFNhZmVseSA9IGVuY3J5cHRTYWZlbHk7XG4vKipcbiAqIERlY3J5cHQgYSBtZXNzYWdlLlxuICpcbiAqIEBwYXJhbSBvcHRpb25zIC0gVGhlIGRlY3J5cHRpb24gb3B0aW9ucy5cbiAqIEBwYXJhbSBvcHRpb25zLmVuY3J5cHRlZERhdGEgLSBUaGUgZW5jcnlwdGVkIGRhdGEuXG4gKiBAcGFyYW0gb3B0aW9ucy5wcml2YXRlS2V5IC0gVGhlIHByaXZhdGUga2V5IHRvIGRlY3J5cHQgd2l0aC5cbiAqIEByZXR1cm5zIFRoZSBkZWNyeXB0ZWQgbWVzc2FnZS5cbiAqL1xuZnVuY3Rpb24gZGVjcnlwdCh7IGVuY3J5cHRlZERhdGEsIHByaXZhdGVLZXksIH0pIHtcbiAgICBpZiAoKDAsIHV0aWxzXzEuaXNOdWxsaXNoKShlbmNyeXB0ZWREYXRhKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01pc3NpbmcgZW5jcnlwdGVkRGF0YSBwYXJhbWV0ZXInKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoKDAsIHV0aWxzXzEuaXNOdWxsaXNoKShwcml2YXRlS2V5KSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01pc3NpbmcgcHJpdmF0ZUtleSBwYXJhbWV0ZXInKTtcbiAgICB9XG4gICAgc3dpdGNoIChlbmNyeXB0ZWREYXRhLnZlcnNpb24pIHtcbiAgICAgICAgY2FzZSAneDI1NTE5LXhzYWxzYTIwLXBvbHkxMzA1Jzoge1xuICAgICAgICAgICAgY29uc3QgcmVjZWl2ZXJQcml2YXRlS2V5VWludDhBcnJheSA9IEJ1ZmZlci5mcm9tKHByaXZhdGVLZXksICdoZXgnKTtcbiAgICAgICAgICAgIGNvbnN0IHJlY2VpdmVyRW5jcnlwdGlvblByaXZhdGVLZXkgPSBuYWNsLmJveC5rZXlQYWlyLmZyb21TZWNyZXRLZXkocmVjZWl2ZXJQcml2YXRlS2V5VWludDhBcnJheSkuc2VjcmV0S2V5O1xuICAgICAgICAgICAgLy8gYXNzZW1ibGUgZGVjcnlwdGlvbiBwYXJhbWV0ZXJzXG4gICAgICAgICAgICBjb25zdCBub25jZSA9IGJhc2VfMS5iYXNlNjQuZGVjb2RlKGVuY3J5cHRlZERhdGEubm9uY2UpO1xuICAgICAgICAgICAgY29uc3QgY2lwaGVydGV4dCA9IGJhc2VfMS5iYXNlNjQuZGVjb2RlKGVuY3J5cHRlZERhdGEuY2lwaGVydGV4dCk7XG4gICAgICAgICAgICBjb25zdCBlcGhlbVB1YmxpY0tleSA9IGJhc2VfMS5iYXNlNjQuZGVjb2RlKGVuY3J5cHRlZERhdGEuZXBoZW1QdWJsaWNLZXkpO1xuICAgICAgICAgICAgLy8gZGVjcnlwdFxuICAgICAgICAgICAgY29uc3QgZGVjcnlwdGVkTWVzc2FnZSA9IG5hY2wuYm94Lm9wZW4oY2lwaGVydGV4dCwgbm9uY2UsIGVwaGVtUHVibGljS2V5LCByZWNlaXZlckVuY3J5cHRpb25Qcml2YXRlS2V5KTtcbiAgICAgICAgICAgIC8vIHJldHVybiBkZWNyeXB0ZWQgbXNnIGRhdGFcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaWYgKCFkZWNyeXB0ZWRNZXNzYWdlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBvdXRwdXQgPSBiYXNlXzEudXRmOC5lbmNvZGUoZGVjcnlwdGVkTWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgLy8gVE9ETzogVGhpcyBpcyBwcm9iYWJseSBleHRyYW5lb3VzIGJ1dCB3YXMga2VwdCB0byBtaW5pbWl6ZSBjaGFuZ2VzIGR1cmluZyByZWZhY3RvclxuICAgICAgICAgICAgICAgIGlmICghb3V0cHV0KSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gb3V0cHV0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIGlmIChlcnIgJiYgdHlwZW9mIGVyci5tZXNzYWdlID09PSAnc3RyaW5nJyAmJiBlcnIubWVzc2FnZS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBEZWNyeXB0aW9uIGZhaWxlZDogJHtlcnIubWVzc2FnZX1gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBEZWNyeXB0aW9uIGZhaWxlZC5gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFbmNyeXB0aW9uIHR5cGUvdmVyc2lvbiBub3Qgc3VwcG9ydGVkLicpO1xuICAgIH1cbn1cbmV4cG9ydHMuZGVjcnlwdCA9IGRlY3J5cHQ7XG4vKipcbiAqIERlY3J5cHQgYSBtZXNzYWdlIHRoYXQgaGFzIGJlZW4gZW5jcnlwdGVkIHVzaW5nIGBlbmNyeXB0U2FmZWx5YC5cbiAqXG4gKiBAcGFyYW0gb3B0aW9ucyAtIFRoZSBkZWNyeXB0aW9uIG9wdGlvbnMuXG4gKiBAcGFyYW0gb3B0aW9ucy5lbmNyeXB0ZWREYXRhIC0gVGhlIGVuY3J5cHRlZCBkYXRhLlxuICogQHBhcmFtIG9wdGlvbnMucHJpdmF0ZUtleSAtIFRoZSBwcml2YXRlIGtleSB0byBkZWNyeXB0IHdpdGguXG4gKiBAcmV0dXJucyBUaGUgZGVjcnlwdGVkIG1lc3NhZ2UuXG4gKi9cbmZ1bmN0aW9uIGRlY3J5cHRTYWZlbHkoeyBlbmNyeXB0ZWREYXRhLCBwcml2YXRlS2V5LCB9KSB7XG4gICAgaWYgKCgwLCB1dGlsc18xLmlzTnVsbGlzaCkoZW5jcnlwdGVkRGF0YSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNaXNzaW5nIGVuY3J5cHRlZERhdGEgcGFyYW1ldGVyJyk7XG4gICAgfVxuICAgIGVsc2UgaWYgKCgwLCB1dGlsc18xLmlzTnVsbGlzaCkocHJpdmF0ZUtleSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNaXNzaW5nIHByaXZhdGVLZXkgcGFyYW1ldGVyJyk7XG4gICAgfVxuICAgIGNvbnN0IGRhdGFXaXRoUGFkZGluZyA9IEpTT04ucGFyc2UoZGVjcnlwdCh7IGVuY3J5cHRlZERhdGEsIHByaXZhdGVLZXkgfSkpO1xuICAgIHJldHVybiBkYXRhV2l0aFBhZGRpbmcuZGF0YTtcbn1cbmV4cG9ydHMuZGVjcnlwdFNhZmVseSA9IGRlY3J5cHRTYWZlbHk7XG4vKipcbiAqIEdldCB0aGUgZW5jcnlwdGlvbiBwdWJsaWMga2V5IGZvciB0aGUgZ2l2ZW4ga2V5LlxuICpcbiAqIEBwYXJhbSBwcml2YXRlS2V5IC0gVGhlIHByaXZhdGUga2V5IHRvIGdlbmVyYXRlIHRoZSBlbmNyeXB0aW9uIHB1YmxpYyBrZXkgd2l0aC5cbiAqIEByZXR1cm5zIFRoZSBlbmNyeXB0aW9uIHB1YmxpYyBrZXkuXG4gKi9cbmZ1bmN0aW9uIGdldEVuY3J5cHRpb25QdWJsaWNLZXkocHJpdmF0ZUtleSkge1xuICAgIGNvbnN0IHByaXZhdGVLZXlVaW50OEFycmF5ID0gQnVmZmVyLmZyb20ocHJpdmF0ZUtleSwgJ2hleCcpO1xuICAgIGNvbnN0IGVuY3J5cHRpb25QdWJsaWNLZXkgPSBuYWNsLmJveC5rZXlQYWlyLmZyb21TZWNyZXRLZXkocHJpdmF0ZUtleVVpbnQ4QXJyYXkpLnB1YmxpY0tleTtcbiAgICByZXR1cm4gYmFzZV8xLmJhc2U2NC5lbmNvZGUoZW5jcnlwdGlvblB1YmxpY0tleSk7XG59XG5leHBvcnRzLmdldEVuY3J5cHRpb25QdWJsaWNLZXkgPSBnZXRFbmNyeXB0aW9uUHVibGljS2V5O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZW5jcnlwdGlvbi5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/.pnpm/@metamask+eth-sig-util@7.0.2/node_modules/@metamask/eth-sig-util/dist/encryption.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/.pnpm/@metamask+eth-sig-util@7.0.2/node_modules/@metamask/eth-sig-util/dist/index.js":
/*!***************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/@metamask+eth-sig-util@7.0.2/node_modules/@metamask/eth-sig-util/dist/index.js ***!
  \***************************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.normalize = exports.concatSig = void 0;\n__exportStar(__webpack_require__(/*! ./personal-sign */ \"(ssr)/../../node_modules/.pnpm/@metamask+eth-sig-util@7.0.2/node_modules/@metamask/eth-sig-util/dist/personal-sign.js\"), exports);\n__exportStar(__webpack_require__(/*! ./sign-typed-data */ \"(ssr)/../../node_modules/.pnpm/@metamask+eth-sig-util@7.0.2/node_modules/@metamask/eth-sig-util/dist/sign-typed-data.js\"), exports);\n__exportStar(__webpack_require__(/*! ./encryption */ \"(ssr)/../../node_modules/.pnpm/@metamask+eth-sig-util@7.0.2/node_modules/@metamask/eth-sig-util/dist/encryption.js\"), exports);\nvar utils_1 = __webpack_require__(/*! ./utils */ \"(ssr)/../../node_modules/.pnpm/@metamask+eth-sig-util@7.0.2/node_modules/@metamask/eth-sig-util/dist/utils.js\");\nObject.defineProperty(exports, \"concatSig\", ({ enumerable: true, get: function () { return utils_1.concatSig; } }));\nObject.defineProperty(exports, \"normalize\", ({ enumerable: true, get: function () { return utils_1.normalize; } }));\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BtZXRhbWFzaytldGgtc2lnLXV0aWxANy4wLjIvbm9kZV9tb2R1bGVzL0BtZXRhbWFzay9ldGgtc2lnLXV0aWwvZGlzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxvQ0FBb0M7QUFDbkQ7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxpQkFBaUIsR0FBRyxpQkFBaUI7QUFDckMsYUFBYSxtQkFBTyxDQUFDLDhJQUFpQjtBQUN0QyxhQUFhLG1CQUFPLENBQUMsa0pBQW1CO0FBQ3hDLGFBQWEsbUJBQU8sQ0FBQyx3SUFBYztBQUNuQyxjQUFjLG1CQUFPLENBQUMsOEhBQVM7QUFDL0IsNkNBQTRDLEVBQUUscUNBQXFDLDZCQUE2QixFQUFDO0FBQ2pILDZDQUE0QyxFQUFFLHFDQUFxQyw2QkFBNkIsRUFBQztBQUNqSCIsInNvdXJjZXMiOlsid2VicGFjazovL0Bjb2xsZWN0aWJsZS93ZWIvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BtZXRhbWFzaytldGgtc2lnLXV0aWxANy4wLjIvbm9kZV9tb2R1bGVzL0BtZXRhbWFzay9ldGgtc2lnLXV0aWwvZGlzdC9pbmRleC5qcz84Y2MyIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XG4gICAgICBkZXNjID0geyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX2V4cG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9fZXhwb3J0U3RhcikgfHwgZnVuY3Rpb24obSwgZXhwb3J0cykge1xuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKHAgIT09IFwiZGVmYXVsdFwiICYmICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZXhwb3J0cywgcCkpIF9fY3JlYXRlQmluZGluZyhleHBvcnRzLCBtLCBwKTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLm5vcm1hbGl6ZSA9IGV4cG9ydHMuY29uY2F0U2lnID0gdm9pZCAwO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL3BlcnNvbmFsLXNpZ25cIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL3NpZ24tdHlwZWQtZGF0YVwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vZW5jcnlwdGlvblwiKSwgZXhwb3J0cyk7XG52YXIgdXRpbHNfMSA9IHJlcXVpcmUoXCIuL3V0aWxzXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiY29uY2F0U2lnXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB1dGlsc18xLmNvbmNhdFNpZzsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIm5vcm1hbGl6ZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdXRpbHNfMS5ub3JtYWxpemU7IH0gfSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/.pnpm/@metamask+eth-sig-util@7.0.2/node_modules/@metamask/eth-sig-util/dist/index.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/.pnpm/@metamask+eth-sig-util@7.0.2/node_modules/@metamask/eth-sig-util/dist/personal-sign.js":
/*!***********************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/@metamask+eth-sig-util@7.0.2/node_modules/@metamask/eth-sig-util/dist/personal-sign.js ***!
  \***********************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.extractPublicKey = exports.recoverPersonalSignature = exports.personalSign = void 0;\nconst util_1 = __webpack_require__(/*! @ethereumjs/util */ \"(ssr)/../../node_modules/.pnpm/@ethereumjs+util@8.1.0/node_modules/@ethereumjs/util/dist/index.js\");\nconst utils_1 = __webpack_require__(/*! ./utils */ \"(ssr)/../../node_modules/.pnpm/@metamask+eth-sig-util@7.0.2/node_modules/@metamask/eth-sig-util/dist/utils.js\");\n/**\n * Create an Ethereum-specific signature for a message.\n *\n * This function is equivalent to the `eth_sign` Ethereum JSON-RPC method as specified in EIP-1417,\n * as well as the MetaMask's `personal_sign` method.\n *\n * @param options - The personal sign options.\n * @param options.privateKey - The key to sign with.\n * @param options.data - The hex data to sign.\n * @returns The '0x'-prefixed hex encoded signature.\n */\nfunction personalSign({ privateKey, data, }) {\n    if ((0, utils_1.isNullish)(data)) {\n        throw new Error('Missing data parameter');\n    }\n    else if ((0, utils_1.isNullish)(privateKey)) {\n        throw new Error('Missing privateKey parameter');\n    }\n    const message = (0, utils_1.legacyToBuffer)(data);\n    const msgHash = (0, util_1.hashPersonalMessage)(message);\n    const sig = (0, util_1.ecsign)(msgHash, privateKey);\n    const serialized = (0, utils_1.concatSig)((0, util_1.toBuffer)(sig.v), sig.r, sig.s);\n    return serialized;\n}\nexports.personalSign = personalSign;\n/**\n * Recover the address of the account used to create the given Ethereum signature. The message\n * must have been signed using the `personalSign` function, or an equivalent function.\n *\n * @param options - The signature recovery options.\n * @param options.data - The hex data that was signed.\n * @param options.signature - The '0x'-prefixed hex encoded message signature.\n * @returns The '0x'-prefixed hex encoded address of the message signer.\n */\nfunction recoverPersonalSignature({ data, signature, }) {\n    if ((0, utils_1.isNullish)(data)) {\n        throw new Error('Missing data parameter');\n    }\n    else if ((0, utils_1.isNullish)(signature)) {\n        throw new Error('Missing signature parameter');\n    }\n    const publicKey = getPublicKeyFor(data, signature);\n    const sender = (0, util_1.publicToAddress)(publicKey);\n    const senderHex = (0, util_1.bufferToHex)(sender);\n    return senderHex;\n}\nexports.recoverPersonalSignature = recoverPersonalSignature;\n/**\n * Recover the public key of the account used to create the given Ethereum signature. The message\n * must have been signed using the `personalSign` function, or an equivalent function.\n *\n * @param options - The public key recovery options.\n * @param options.data - The hex data that was signed.\n * @param options.signature - The '0x'-prefixed hex encoded message signature.\n * @returns The '0x'-prefixed hex encoded public key of the message signer.\n */\nfunction extractPublicKey({ data, signature, }) {\n    if ((0, utils_1.isNullish)(data)) {\n        throw new Error('Missing data parameter');\n    }\n    else if ((0, utils_1.isNullish)(signature)) {\n        throw new Error('Missing signature parameter');\n    }\n    const publicKey = getPublicKeyFor(data, signature);\n    return `0x${publicKey.toString('hex')}`;\n}\nexports.extractPublicKey = extractPublicKey;\n/**\n * Get the public key for the given signature and message.\n *\n * @param message - The message that was signed.\n * @param signature - The '0x'-prefixed hex encoded message signature.\n * @returns The public key of the signer.\n */\nfunction getPublicKeyFor(message, signature) {\n    const messageHash = (0, util_1.hashPersonalMessage)((0, utils_1.legacyToBuffer)(message));\n    return (0, utils_1.recoverPublicKey)(messageHash, signature);\n}\n//# sourceMappingURL=personal-sign.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BtZXRhbWFzaytldGgtc2lnLXV0aWxANy4wLjIvbm9kZV9tb2R1bGVzL0BtZXRhbWFzay9ldGgtc2lnLXV0aWwvZGlzdC9wZXJzb25hbC1zaWduLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHdCQUF3QixHQUFHLGdDQUFnQyxHQUFHLG9CQUFvQjtBQUNsRixlQUFlLG1CQUFPLENBQUMsMkhBQWtCO0FBQ3pDLGdCQUFnQixtQkFBTyxDQUFDLDhIQUFTO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsbUJBQW1CO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0Msa0JBQWtCO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGtCQUFrQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiwwQkFBMEI7QUFDMUM7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQGNvbGxlY3RpYmxlL3dlYi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vQG1ldGFtYXNrK2V0aC1zaWctdXRpbEA3LjAuMi9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL2V0aC1zaWctdXRpbC9kaXN0L3BlcnNvbmFsLXNpZ24uanM/MzY2OSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZXh0cmFjdFB1YmxpY0tleSA9IGV4cG9ydHMucmVjb3ZlclBlcnNvbmFsU2lnbmF0dXJlID0gZXhwb3J0cy5wZXJzb25hbFNpZ24gPSB2b2lkIDA7XG5jb25zdCB1dGlsXzEgPSByZXF1aXJlKFwiQGV0aGVyZXVtanMvdXRpbFwiKTtcbmNvbnN0IHV0aWxzXzEgPSByZXF1aXJlKFwiLi91dGlsc1wiKTtcbi8qKlxuICogQ3JlYXRlIGFuIEV0aGVyZXVtLXNwZWNpZmljIHNpZ25hdHVyZSBmb3IgYSBtZXNzYWdlLlxuICpcbiAqIFRoaXMgZnVuY3Rpb24gaXMgZXF1aXZhbGVudCB0byB0aGUgYGV0aF9zaWduYCBFdGhlcmV1bSBKU09OLVJQQyBtZXRob2QgYXMgc3BlY2lmaWVkIGluIEVJUC0xNDE3LFxuICogYXMgd2VsbCBhcyB0aGUgTWV0YU1hc2sncyBgcGVyc29uYWxfc2lnbmAgbWV0aG9kLlxuICpcbiAqIEBwYXJhbSBvcHRpb25zIC0gVGhlIHBlcnNvbmFsIHNpZ24gb3B0aW9ucy5cbiAqIEBwYXJhbSBvcHRpb25zLnByaXZhdGVLZXkgLSBUaGUga2V5IHRvIHNpZ24gd2l0aC5cbiAqIEBwYXJhbSBvcHRpb25zLmRhdGEgLSBUaGUgaGV4IGRhdGEgdG8gc2lnbi5cbiAqIEByZXR1cm5zIFRoZSAnMHgnLXByZWZpeGVkIGhleCBlbmNvZGVkIHNpZ25hdHVyZS5cbiAqL1xuZnVuY3Rpb24gcGVyc29uYWxTaWduKHsgcHJpdmF0ZUtleSwgZGF0YSwgfSkge1xuICAgIGlmICgoMCwgdXRpbHNfMS5pc051bGxpc2gpKGRhdGEpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTWlzc2luZyBkYXRhIHBhcmFtZXRlcicpO1xuICAgIH1cbiAgICBlbHNlIGlmICgoMCwgdXRpbHNfMS5pc051bGxpc2gpKHByaXZhdGVLZXkpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTWlzc2luZyBwcml2YXRlS2V5IHBhcmFtZXRlcicpO1xuICAgIH1cbiAgICBjb25zdCBtZXNzYWdlID0gKDAsIHV0aWxzXzEubGVnYWN5VG9CdWZmZXIpKGRhdGEpO1xuICAgIGNvbnN0IG1zZ0hhc2ggPSAoMCwgdXRpbF8xLmhhc2hQZXJzb25hbE1lc3NhZ2UpKG1lc3NhZ2UpO1xuICAgIGNvbnN0IHNpZyA9ICgwLCB1dGlsXzEuZWNzaWduKShtc2dIYXNoLCBwcml2YXRlS2V5KTtcbiAgICBjb25zdCBzZXJpYWxpemVkID0gKDAsIHV0aWxzXzEuY29uY2F0U2lnKSgoMCwgdXRpbF8xLnRvQnVmZmVyKShzaWcudiksIHNpZy5yLCBzaWcucyk7XG4gICAgcmV0dXJuIHNlcmlhbGl6ZWQ7XG59XG5leHBvcnRzLnBlcnNvbmFsU2lnbiA9IHBlcnNvbmFsU2lnbjtcbi8qKlxuICogUmVjb3ZlciB0aGUgYWRkcmVzcyBvZiB0aGUgYWNjb3VudCB1c2VkIHRvIGNyZWF0ZSB0aGUgZ2l2ZW4gRXRoZXJldW0gc2lnbmF0dXJlLiBUaGUgbWVzc2FnZVxuICogbXVzdCBoYXZlIGJlZW4gc2lnbmVkIHVzaW5nIHRoZSBgcGVyc29uYWxTaWduYCBmdW5jdGlvbiwgb3IgYW4gZXF1aXZhbGVudCBmdW5jdGlvbi5cbiAqXG4gKiBAcGFyYW0gb3B0aW9ucyAtIFRoZSBzaWduYXR1cmUgcmVjb3Zlcnkgb3B0aW9ucy5cbiAqIEBwYXJhbSBvcHRpb25zLmRhdGEgLSBUaGUgaGV4IGRhdGEgdGhhdCB3YXMgc2lnbmVkLlxuICogQHBhcmFtIG9wdGlvbnMuc2lnbmF0dXJlIC0gVGhlICcweCctcHJlZml4ZWQgaGV4IGVuY29kZWQgbWVzc2FnZSBzaWduYXR1cmUuXG4gKiBAcmV0dXJucyBUaGUgJzB4Jy1wcmVmaXhlZCBoZXggZW5jb2RlZCBhZGRyZXNzIG9mIHRoZSBtZXNzYWdlIHNpZ25lci5cbiAqL1xuZnVuY3Rpb24gcmVjb3ZlclBlcnNvbmFsU2lnbmF0dXJlKHsgZGF0YSwgc2lnbmF0dXJlLCB9KSB7XG4gICAgaWYgKCgwLCB1dGlsc18xLmlzTnVsbGlzaCkoZGF0YSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNaXNzaW5nIGRhdGEgcGFyYW1ldGVyJyk7XG4gICAgfVxuICAgIGVsc2UgaWYgKCgwLCB1dGlsc18xLmlzTnVsbGlzaCkoc2lnbmF0dXJlKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01pc3Npbmcgc2lnbmF0dXJlIHBhcmFtZXRlcicpO1xuICAgIH1cbiAgICBjb25zdCBwdWJsaWNLZXkgPSBnZXRQdWJsaWNLZXlGb3IoZGF0YSwgc2lnbmF0dXJlKTtcbiAgICBjb25zdCBzZW5kZXIgPSAoMCwgdXRpbF8xLnB1YmxpY1RvQWRkcmVzcykocHVibGljS2V5KTtcbiAgICBjb25zdCBzZW5kZXJIZXggPSAoMCwgdXRpbF8xLmJ1ZmZlclRvSGV4KShzZW5kZXIpO1xuICAgIHJldHVybiBzZW5kZXJIZXg7XG59XG5leHBvcnRzLnJlY292ZXJQZXJzb25hbFNpZ25hdHVyZSA9IHJlY292ZXJQZXJzb25hbFNpZ25hdHVyZTtcbi8qKlxuICogUmVjb3ZlciB0aGUgcHVibGljIGtleSBvZiB0aGUgYWNjb3VudCB1c2VkIHRvIGNyZWF0ZSB0aGUgZ2l2ZW4gRXRoZXJldW0gc2lnbmF0dXJlLiBUaGUgbWVzc2FnZVxuICogbXVzdCBoYXZlIGJlZW4gc2lnbmVkIHVzaW5nIHRoZSBgcGVyc29uYWxTaWduYCBmdW5jdGlvbiwgb3IgYW4gZXF1aXZhbGVudCBmdW5jdGlvbi5cbiAqXG4gKiBAcGFyYW0gb3B0aW9ucyAtIFRoZSBwdWJsaWMga2V5IHJlY292ZXJ5IG9wdGlvbnMuXG4gKiBAcGFyYW0gb3B0aW9ucy5kYXRhIC0gVGhlIGhleCBkYXRhIHRoYXQgd2FzIHNpZ25lZC5cbiAqIEBwYXJhbSBvcHRpb25zLnNpZ25hdHVyZSAtIFRoZSAnMHgnLXByZWZpeGVkIGhleCBlbmNvZGVkIG1lc3NhZ2Ugc2lnbmF0dXJlLlxuICogQHJldHVybnMgVGhlICcweCctcHJlZml4ZWQgaGV4IGVuY29kZWQgcHVibGljIGtleSBvZiB0aGUgbWVzc2FnZSBzaWduZXIuXG4gKi9cbmZ1bmN0aW9uIGV4dHJhY3RQdWJsaWNLZXkoeyBkYXRhLCBzaWduYXR1cmUsIH0pIHtcbiAgICBpZiAoKDAsIHV0aWxzXzEuaXNOdWxsaXNoKShkYXRhKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01pc3NpbmcgZGF0YSBwYXJhbWV0ZXInKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoKDAsIHV0aWxzXzEuaXNOdWxsaXNoKShzaWduYXR1cmUpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTWlzc2luZyBzaWduYXR1cmUgcGFyYW1ldGVyJyk7XG4gICAgfVxuICAgIGNvbnN0IHB1YmxpY0tleSA9IGdldFB1YmxpY0tleUZvcihkYXRhLCBzaWduYXR1cmUpO1xuICAgIHJldHVybiBgMHgke3B1YmxpY0tleS50b1N0cmluZygnaGV4Jyl9YDtcbn1cbmV4cG9ydHMuZXh0cmFjdFB1YmxpY0tleSA9IGV4dHJhY3RQdWJsaWNLZXk7XG4vKipcbiAqIEdldCB0aGUgcHVibGljIGtleSBmb3IgdGhlIGdpdmVuIHNpZ25hdHVyZSBhbmQgbWVzc2FnZS5cbiAqXG4gKiBAcGFyYW0gbWVzc2FnZSAtIFRoZSBtZXNzYWdlIHRoYXQgd2FzIHNpZ25lZC5cbiAqIEBwYXJhbSBzaWduYXR1cmUgLSBUaGUgJzB4Jy1wcmVmaXhlZCBoZXggZW5jb2RlZCBtZXNzYWdlIHNpZ25hdHVyZS5cbiAqIEByZXR1cm5zIFRoZSBwdWJsaWMga2V5IG9mIHRoZSBzaWduZXIuXG4gKi9cbmZ1bmN0aW9uIGdldFB1YmxpY0tleUZvcihtZXNzYWdlLCBzaWduYXR1cmUpIHtcbiAgICBjb25zdCBtZXNzYWdlSGFzaCA9ICgwLCB1dGlsXzEuaGFzaFBlcnNvbmFsTWVzc2FnZSkoKDAsIHV0aWxzXzEubGVnYWN5VG9CdWZmZXIpKG1lc3NhZ2UpKTtcbiAgICByZXR1cm4gKDAsIHV0aWxzXzEucmVjb3ZlclB1YmxpY0tleSkobWVzc2FnZUhhc2gsIHNpZ25hdHVyZSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wZXJzb25hbC1zaWduLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/.pnpm/@metamask+eth-sig-util@7.0.2/node_modules/@metamask/eth-sig-util/dist/personal-sign.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/.pnpm/@metamask+eth-sig-util@7.0.2/node_modules/@metamask/eth-sig-util/dist/sign-typed-data.js":
/*!*************************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/@metamask+eth-sig-util@7.0.2/node_modules/@metamask/eth-sig-util/dist/sign-typed-data.js ***!
  \*************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.recoverTypedSignature = exports.signTypedData = exports.typedSignatureHash = exports.TypedDataUtils = exports.TYPED_MESSAGE_SCHEMA = exports.SignTypedDataVersion = void 0;\nconst util_1 = __webpack_require__(/*! @ethereumjs/util */ \"(ssr)/../../node_modules/.pnpm/@ethereumjs+util@8.1.0/node_modules/@ethereumjs/util/dist/index.js\");\nconst abi_utils_1 = __webpack_require__(/*! @metamask/abi-utils */ \"(ssr)/../../node_modules/.pnpm/@metamask+abi-utils@2.0.4/node_modules/@metamask/abi-utils/dist/index.js\");\nconst parsers_1 = __webpack_require__(/*! @metamask/abi-utils/dist/parsers */ \"(ssr)/../../node_modules/.pnpm/@metamask+abi-utils@2.0.4/node_modules/@metamask/abi-utils/dist/parsers/index.js\");\nconst utils_1 = __webpack_require__(/*! @metamask/abi-utils/dist/utils */ \"(ssr)/../../node_modules/.pnpm/@metamask+abi-utils@2.0.4/node_modules/@metamask/abi-utils/dist/utils/index.js\");\nconst utils_2 = __webpack_require__(/*! @metamask/utils */ \"(ssr)/../../node_modules/.pnpm/@metamask+utils@8.5.0/node_modules/@metamask/utils/dist/index.cjs\");\nconst keccak_1 = __webpack_require__(/*! ethereum-cryptography/keccak */ \"(ssr)/../../node_modules/.pnpm/ethereum-cryptography@2.2.1/node_modules/ethereum-cryptography/keccak.js\");\nconst utils_3 = __webpack_require__(/*! ./utils */ \"(ssr)/../../node_modules/.pnpm/@metamask+eth-sig-util@7.0.2/node_modules/@metamask/eth-sig-util/dist/utils.js\");\n/**\n * Represents the version of `signTypedData` being used.\n *\n * V1 is based upon [an early version of\n * EIP-712](https://github.com/ethereum/EIPs/pull/712/commits/21abe254fe0452d8583d5b132b1d7be87c0439ca)\n * that lacked some later security improvements, and should generally be neglected in favor of\n * later versions.\n *\n * V3 is based on EIP-712, except that arrays and recursive data structures are not supported.\n *\n * V4 is based on EIP-712, and includes full support of arrays and recursive data structures.\n */\nvar SignTypedDataVersion;\n(function (SignTypedDataVersion) {\n    SignTypedDataVersion[\"V1\"] = \"V1\";\n    SignTypedDataVersion[\"V3\"] = \"V3\";\n    SignTypedDataVersion[\"V4\"] = \"V4\";\n})(SignTypedDataVersion = exports.SignTypedDataVersion || (exports.SignTypedDataVersion = {}));\nexports.TYPED_MESSAGE_SCHEMA = {\n    type: 'object',\n    properties: {\n        types: {\n            type: 'object',\n            additionalProperties: {\n                type: 'array',\n                items: {\n                    type: 'object',\n                    properties: {\n                        name: { type: 'string' },\n                        type: { type: 'string' },\n                    },\n                    required: ['name', 'type'],\n                },\n            },\n        },\n        primaryType: { type: 'string' },\n        domain: { type: 'object' },\n        message: { type: 'object' },\n    },\n    required: ['types', 'primaryType', 'domain', 'message'],\n};\n/**\n * Validate that the given value is a valid version string.\n *\n * @param version - The version value to validate.\n * @param allowedVersions - A list of allowed versions. If omitted, all versions are assumed to be\n * allowed.\n */\nfunction validateVersion(version, allowedVersions) {\n    if (!Object.keys(SignTypedDataVersion).includes(version)) {\n        throw new Error(`Invalid version: '${version}'`);\n    }\n    else if (allowedVersions && !allowedVersions.includes(version)) {\n        throw new Error(`SignTypedDataVersion not allowed: '${version}'. Allowed versions are: ${allowedVersions.join(', ')}`);\n    }\n}\n/**\n * Parse a string, number, or bigint value into a `Uint8Array`.\n *\n * @param type - The type of the value.\n * @param value - The value to parse.\n * @returns The parsed value.\n */\nfunction parseNumber(type, value) {\n    (0, utils_2.assert)(value !== null, `Unable to encode value: Invalid number. Expected a valid number value, but received \"${value}\".`);\n    const bigIntValue = BigInt(value);\n    const length = (0, parsers_1.getLength)(type);\n    const maxValue = BigInt(2) ** BigInt(length) - BigInt(1);\n    // Note that this is not accurate, since the actual maximum value for unsigned\n    // integers is `2 ^ (length - 1) - 1`, but this is required for backwards\n    // compatibility with the old implementation.\n    (0, utils_2.assert)(bigIntValue >= -maxValue && bigIntValue <= maxValue, `Unable to encode value: Number \"${value}\" is out of range for type \"${type}\".`);\n    return bigIntValue;\n}\n/**\n * Parse an address string to a `Uint8Array`. The behaviour of this is quite\n * strange, in that it does not parse the address as hexadecimal string, nor as\n * UTF-8. It does some weird stuff with the string and char codes, and then\n * returns the result as a `Uint8Array`.\n *\n * This is based on the old `ethereumjs-abi` implementation, which essentially\n * calls `new BN(address, 10)` on the address string, the equivalent of calling\n * `parseInt(address, 10)` in JavaScript. This is not a valid way to parse an\n * address and would result in `NaN` in plain JavaScript, but it is the\n * behaviour of the old implementation, and so we must preserve it for backwards\n * compatibility.\n *\n * @param address - The address to parse.\n * @returns The parsed address.\n */\nfunction reallyStrangeAddressToBytes(address) {\n    let addressValue = BigInt(0);\n    for (let i = 0; i < address.length; i++) {\n        const character = BigInt(address.charCodeAt(i) - 48);\n        addressValue *= BigInt(10);\n        // 'a'\n        if (character >= 49) {\n            addressValue += character - BigInt(49) + BigInt(0xa);\n            // 'A'\n        }\n        else if (character >= 17) {\n            addressValue += character - BigInt(17) + BigInt(0xa);\n            // '0' - '9'\n        }\n        else {\n            addressValue += character;\n        }\n    }\n    return (0, utils_1.padStart)((0, utils_2.bigIntToBytes)(addressValue), 20);\n}\n/**\n * Encode a single field.\n *\n * @param types - All type definitions.\n * @param name - The name of the field to encode.\n * @param type - The type of the field being encoded.\n * @param value - The value to encode.\n * @param version - The EIP-712 version the encoding should comply with.\n * @returns Encoded representation of the field.\n */\nfunction encodeField(types, name, type, \n// TODO: constrain type on `value`\nvalue, version) {\n    validateVersion(version, [SignTypedDataVersion.V3, SignTypedDataVersion.V4]);\n    if (types[type] !== undefined) {\n        return [\n            'bytes32',\n            // TODO: return Buffer, remove string from return type\n            version === SignTypedDataVersion.V4 && value == null // eslint-disable-line no-eq-null\n                ? '0x0000000000000000000000000000000000000000000000000000000000000000'\n                : (0, util_1.arrToBufArr)((0, keccak_1.keccak256)(encodeData(type, value, types, version))),\n        ];\n    }\n    // `function` is supported in `@metamask/abi-utils`, but not allowed by\n    // EIP-712, so we throw an error here.\n    if (type === 'function') {\n        throw new Error('Unsupported or invalid type: \"function\"');\n    }\n    if (value === undefined) {\n        throw new Error(`missing value for field ${name} of type ${type}`);\n    }\n    if (type === 'address') {\n        if (typeof value === 'number') {\n            return ['address', (0, utils_1.padStart)((0, utils_2.numberToBytes)(value), 20)];\n        }\n        else if ((0, utils_2.isStrictHexString)(value)) {\n            return ['address', (0, utils_2.add0x)(value)];\n        }\n        else if (typeof value === 'string') {\n            return ['address', reallyStrangeAddressToBytes(value).subarray(0, 20)];\n        }\n    }\n    if (type === 'bool') {\n        return ['bool', Boolean(value)];\n    }\n    if (type === 'bytes') {\n        if (typeof value === 'number') {\n            value = (0, utils_2.numberToBytes)(value);\n        }\n        else if ((0, utils_2.isStrictHexString)(value) || value === '0x') {\n            value = (0, utils_2.hexToBytes)(value);\n        }\n        else if (typeof value === 'string') {\n            value = (0, utils_2.stringToBytes)(value);\n        }\n        return ['bytes32', (0, util_1.arrToBufArr)((0, keccak_1.keccak256)(value))];\n    }\n    if (type.startsWith('bytes') && type !== 'bytes' && !type.includes('[')) {\n        if (typeof value === 'number') {\n            if (value < 0) {\n                return ['bytes32', new Uint8Array(32)];\n            }\n            return ['bytes32', (0, utils_2.bigIntToBytes)(BigInt(value))];\n        }\n        else if ((0, utils_2.isStrictHexString)(value)) {\n            return ['bytes32', (0, utils_2.hexToBytes)(value)];\n        }\n        return ['bytes32', value];\n    }\n    if (type.startsWith('int') && !type.includes('[')) {\n        const bigIntValue = parseNumber(type, value);\n        if (bigIntValue >= BigInt(0)) {\n            return ['uint256', bigIntValue];\n        }\n        return ['int256', bigIntValue];\n    }\n    if (type === 'string') {\n        if (typeof value === 'number') {\n            value = (0, utils_2.numberToBytes)(value);\n        }\n        else {\n            value = (0, utils_2.stringToBytes)(value !== null && value !== void 0 ? value : '');\n        }\n        return ['bytes32', (0, util_1.arrToBufArr)((0, keccak_1.keccak256)(value))];\n    }\n    if (type.endsWith(']')) {\n        if (version === SignTypedDataVersion.V3) {\n            throw new Error('Arrays are unimplemented in encodeData; use V4 extension');\n        }\n        const parsedType = type.slice(0, type.lastIndexOf('['));\n        const typeValuePairs = value.map((item) => encodeField(types, name, parsedType, item, version));\n        return [\n            'bytes32',\n            (0, util_1.arrToBufArr)((0, keccak_1.keccak256)((0, abi_utils_1.encode)(typeValuePairs.map(([t]) => t), typeValuePairs.map(([, v]) => v)))),\n        ];\n    }\n    return [type, value];\n}\n/**\n * Encodes an object by encoding and concatenating each of its members.\n *\n * @param primaryType - The root type.\n * @param data - The object to encode.\n * @param types - Type definitions for all types included in the message.\n * @param version - The EIP-712 version the encoding should comply with.\n * @returns An encoded representation of an object.\n */\nfunction encodeData(primaryType, data, types, version) {\n    validateVersion(version, [SignTypedDataVersion.V3, SignTypedDataVersion.V4]);\n    const encodedTypes = ['bytes32'];\n    const encodedValues = [\n        hashType(primaryType, types),\n    ];\n    for (const field of types[primaryType]) {\n        if (version === SignTypedDataVersion.V3 && data[field.name] === undefined) {\n            continue;\n        }\n        const [type, value] = encodeField(types, field.name, field.type, data[field.name], version);\n        encodedTypes.push(type);\n        encodedValues.push(value);\n    }\n    return (0, util_1.arrToBufArr)((0, abi_utils_1.encode)(encodedTypes, encodedValues));\n}\n/**\n * Encodes the type of an object by encoding a comma delimited list of its members.\n *\n * @param primaryType - The root type to encode.\n * @param types - Type definitions for all types included in the message.\n * @returns An encoded representation of the primary type.\n */\nfunction encodeType(primaryType, types) {\n    let result = '';\n    const unsortedDeps = findTypeDependencies(primaryType, types);\n    unsortedDeps.delete(primaryType);\n    const deps = [primaryType, ...Array.from(unsortedDeps).sort()];\n    for (const type of deps) {\n        const children = types[type];\n        if (!children) {\n            throw new Error(`No type definition specified: ${type}`);\n        }\n        result += `${type}(${types[type]\n            .map(({ name, type: t }) => `${t} ${name}`)\n            .join(',')})`;\n    }\n    return result;\n}\n/**\n * Finds all types within a type definition object.\n *\n * @param primaryType - The root type.\n * @param types - Type definitions for all types included in the message.\n * @param results - The current set of accumulated types.\n * @returns The set of all types found in the type definition.\n */\nfunction findTypeDependencies(primaryType, types, results = new Set()) {\n    if (typeof primaryType !== 'string') {\n        throw new Error(`Invalid findTypeDependencies input ${JSON.stringify(primaryType)}`);\n    }\n    const match = primaryType.match(/^\\w*/u);\n    [primaryType] = match;\n    if (results.has(primaryType) || types[primaryType] === undefined) {\n        return results;\n    }\n    results.add(primaryType);\n    for (const field of types[primaryType]) {\n        findTypeDependencies(field.type, types, results);\n    }\n    return results;\n}\n/**\n * Hashes an object.\n *\n * @param primaryType - The root type.\n * @param data - The object to hash.\n * @param types - Type definitions for all types included in the message.\n * @param version - The EIP-712 version the encoding should comply with.\n * @returns The hash of the object.\n */\nfunction hashStruct(primaryType, data, types, version) {\n    validateVersion(version, [SignTypedDataVersion.V3, SignTypedDataVersion.V4]);\n    const encoded = encodeData(primaryType, data, types, version);\n    const hashed = (0, keccak_1.keccak256)(encoded);\n    const buf = (0, util_1.arrToBufArr)(hashed);\n    return buf;\n}\n/**\n * Hashes the type of an object.\n *\n * @param primaryType - The root type to hash.\n * @param types - Type definitions for all types included in the message.\n * @returns The hash of the object type.\n */\nfunction hashType(primaryType, types) {\n    const encodedHashType = (0, utils_2.stringToBytes)(encodeType(primaryType, types));\n    return (0, util_1.arrToBufArr)((0, keccak_1.keccak256)(encodedHashType));\n}\n/**\n * Removes properties from a message object that are not defined per EIP-712.\n *\n * @param data - The typed message object.\n * @returns The typed message object with only allowed fields.\n */\nfunction sanitizeData(data) {\n    const sanitizedData = {};\n    for (const key in exports.TYPED_MESSAGE_SCHEMA.properties) {\n        if (data[key]) {\n            sanitizedData[key] = data[key];\n        }\n    }\n    if ('types' in sanitizedData) {\n        // TODO: Fix types\n        sanitizedData.types = Object.assign({ EIP712Domain: [] }, sanitizedData.types);\n    }\n    return sanitizedData;\n}\n/**\n * Create a EIP-712 Domain Hash.\n * This hash is used at the top of the EIP-712 encoding.\n *\n * @param typedData - The typed message to hash.\n * @param version - The EIP-712 version the encoding should comply with.\n * @returns The hash of the domain object.\n */\nfunction eip712DomainHash(typedData, version) {\n    validateVersion(version, [SignTypedDataVersion.V3, SignTypedDataVersion.V4]);\n    const sanitizedData = sanitizeData(typedData);\n    const { domain } = sanitizedData;\n    const domainType = { EIP712Domain: sanitizedData.types.EIP712Domain };\n    return hashStruct('EIP712Domain', domain, domainType, version);\n}\n/**\n * Hash a typed message according to EIP-712. The returned message starts with the EIP-712 prefix,\n * which is \"1901\", followed by the hash of the domain separator, then the data (if any).\n * The result is hashed again and returned.\n *\n * This function does not sign the message. The resulting hash must still be signed to create an\n * EIP-712 signature.\n *\n * @param typedData - The typed message to hash.\n * @param version - The EIP-712 version the encoding should comply with.\n * @returns The hash of the typed message.\n */\nfunction eip712Hash(typedData, version) {\n    validateVersion(version, [SignTypedDataVersion.V3, SignTypedDataVersion.V4]);\n    const sanitizedData = sanitizeData(typedData);\n    const parts = [(0, utils_2.hexToBytes)('1901')];\n    parts.push(eip712DomainHash(typedData, version));\n    if (sanitizedData.primaryType !== 'EIP712Domain') {\n        parts.push(hashStruct(\n        // TODO: Validate that this is a string, so this type cast can be removed.\n        sanitizedData.primaryType, sanitizedData.message, sanitizedData.types, version));\n    }\n    return (0, util_1.arrToBufArr)((0, keccak_1.keccak256)((0, utils_2.concatBytes)(parts)));\n}\n/**\n * A collection of utility functions used for signing typed data.\n */\nexports.TypedDataUtils = {\n    encodeData,\n    encodeType,\n    findTypeDependencies,\n    hashStruct,\n    hashType,\n    sanitizeData,\n    eip712Hash,\n    eip712DomainHash,\n};\n/**\n * Generate the \"V1\" hash for the provided typed message.\n *\n * The hash will be generated in accordance with an earlier version of the EIP-712\n * specification. This hash is used in `signTypedData_v1`.\n *\n * @param typedData - The typed message.\n * @returns The '0x'-prefixed hex encoded hash representing the type of the provided message.\n */\nfunction typedSignatureHash(typedData) {\n    const hashBuffer = _typedSignatureHash(typedData);\n    return (0, utils_2.bytesToHex)(hashBuffer);\n}\nexports.typedSignatureHash = typedSignatureHash;\n/**\n * Normalize a value, so that `@metamask/abi-utils` can handle it. This\n * matches the behaviour of the `ethereumjs-abi` library.\n *\n * @param type - The type of the value to normalize.\n * @param value - The value to normalize.\n * @returns The normalized value.\n */\nfunction normalizeValue(type, value) {\n    if ((0, parsers_1.isArrayType)(type) && Array.isArray(value)) {\n        const [innerType] = (0, parsers_1.getArrayType)(type);\n        return value.map((item) => normalizeValue(innerType, item));\n    }\n    if (type === 'address') {\n        if (typeof value === 'number') {\n            return (0, utils_1.padStart)((0, utils_2.numberToBytes)(value), 20);\n        }\n        if ((0, utils_2.isStrictHexString)(value)) {\n            return (0, utils_1.padStart)((0, utils_2.hexToBytes)(value).subarray(0, 20), 20);\n        }\n        if (value instanceof Uint8Array) {\n            return (0, utils_1.padStart)(value.subarray(0, 20), 20);\n        }\n    }\n    if (type === 'bool') {\n        return Boolean(value);\n    }\n    if (type.startsWith('bytes') && type !== 'bytes') {\n        const length = (0, parsers_1.getByteLength)(type);\n        if (typeof value === 'number') {\n            if (value < 0) {\n                // `solidityPack(['bytesN'], [-1])` returns `0x00..00`.\n                return new Uint8Array();\n            }\n            return (0, utils_2.numberToBytes)(value).subarray(0, length);\n        }\n        if ((0, utils_2.isStrictHexString)(value)) {\n            return (0, utils_2.hexToBytes)(value).subarray(0, length);\n        }\n        if (value instanceof Uint8Array) {\n            return value.subarray(0, length);\n        }\n    }\n    if (type.startsWith('uint')) {\n        if (typeof value === 'number') {\n            return Math.abs(value);\n        }\n    }\n    if (type.startsWith('int')) {\n        if (typeof value === 'number') {\n            const length = (0, parsers_1.getLength)(type);\n            return BigInt.asIntN(length, BigInt(value));\n        }\n    }\n    return value;\n}\n/**\n * For some reason `ethereumjs-abi` treats `address` and `address[]` differently\n * so we need to normalize `address[]` differently.\n *\n * @param values - The values to normalize.\n * @returns The normalized values.\n */\nfunction normalizeAddresses(values) {\n    return values.map((value) => {\n        if (typeof value === 'number') {\n            return (0, utils_1.padStart)((0, utils_2.numberToBytes)(value), 32);\n        }\n        if ((0, utils_2.isStrictHexString)(value)) {\n            return (0, utils_1.padStart)((0, utils_2.hexToBytes)(value).subarray(0, 32), 32);\n        }\n        if (value instanceof Uint8Array) {\n            return (0, utils_1.padStart)(value.subarray(0, 32), 32);\n        }\n        return value;\n    });\n}\n/**\n * For some reason `ethereumjs-abi` treats `intN` and `intN[]` differently\n * so we need to normalize `intN[]` differently.\n *\n * @param type - The type of the value to normalize.\n * @param values - The values to normalize.\n * @returns The normalized values.\n */\nfunction normalizeIntegers(type, values) {\n    return values.map((value) => {\n        if (typeof value === 'string' ||\n            typeof value === 'number' ||\n            typeof value === 'bigint') {\n            const bigIntValue = parseNumber(type, value);\n            if (bigIntValue >= BigInt(0)) {\n                return (0, utils_1.padStart)((0, utils_2.bigIntToBytes)(bigIntValue), 32);\n            }\n            const length = (0, parsers_1.getLength)(type);\n            const asIntN = BigInt.asIntN(length, bigIntValue);\n            return (0, utils_2.signedBigIntToBytes)(asIntN, 32);\n        }\n        return value;\n    });\n}\n/**\n * Generate the \"V1\" hash for the provided typed message.\n *\n * The hash will be generated in accordance with an earlier version of the EIP-712\n * specification. This hash is used in `signTypedData_v1`.\n *\n * @param typedData - The typed message.\n * @returns The hash representing the type of the provided message.\n */\nfunction _typedSignatureHash(typedData) {\n    const error = new Error('Expect argument to be non-empty array');\n    if (typeof typedData !== 'object' ||\n        !('length' in typedData) ||\n        !typedData.length) {\n        throw error;\n    }\n    const normalizedData = typedData.map(({ name, type, value }) => {\n        // Handle an edge case with `address[]` types.\n        if (type === 'address[]') {\n            return {\n                name,\n                type: 'bytes32[]',\n                value: normalizeAddresses(value),\n            };\n        }\n        // Handle an edge case with `intN[]` types.\n        if (type.startsWith('int') && (0, parsers_1.isArrayType)(type)) {\n            const [innerType, length] = (0, parsers_1.getArrayType)(type);\n            return {\n                name,\n                type: `bytes32[${length !== null && length !== void 0 ? length : ''}]`,\n                value: normalizeIntegers(innerType, value),\n            };\n        }\n        return {\n            name,\n            type,\n            value: normalizeValue(type, value),\n        };\n    });\n    const data = normalizedData.map((e) => {\n        if (e.type !== 'bytes') {\n            return e.value;\n        }\n        return (0, utils_3.legacyToBuffer)(e.value);\n    });\n    const types = normalizedData.map((e) => {\n        if (e.type === 'function') {\n            throw new Error('Unsupported or invalid type: \"function\"');\n        }\n        return e.type;\n    });\n    const schema = typedData.map((e) => {\n        if (!e.name) {\n            throw error;\n        }\n        return `${e.type} ${e.name}`;\n    });\n    return (0, util_1.arrToBufArr)((0, keccak_1.keccak256)((0, abi_utils_1.encodePacked)(['bytes32', 'bytes32'], [\n        (0, keccak_1.keccak256)((0, abi_utils_1.encodePacked)(['string[]'], [schema], true)),\n        (0, keccak_1.keccak256)((0, abi_utils_1.encodePacked)(types, data, true)),\n    ])));\n}\n/**\n * Sign typed data according to EIP-712. The signing differs based upon the `version`.\n *\n * V1 is based upon [an early version of\n * EIP-712](https://github.com/ethereum/EIPs/pull/712/commits/21abe254fe0452d8583d5b132b1d7be87c0439ca)\n * that lacked some later security improvements, and should generally be neglected in favor of\n * later versions.\n *\n * V3 is based on [EIP-712](https://eips.ethereum.org/EIPS/eip-712), except that arrays and\n * recursive data structures are not supported.\n *\n * V4 is based on [EIP-712](https://eips.ethereum.org/EIPS/eip-712), and includes full support of\n * arrays and recursive data structures.\n *\n * @param options - The signing options.\n * @param options.privateKey - The private key to sign with.\n * @param options.data - The typed data to sign.\n * @param options.version - The signing version to use.\n * @returns The '0x'-prefixed hex encoded signature.\n */\nfunction signTypedData({ privateKey, data, version, }) {\n    validateVersion(version);\n    if ((0, utils_3.isNullish)(data)) {\n        throw new Error('Missing data parameter');\n    }\n    else if ((0, utils_3.isNullish)(privateKey)) {\n        throw new Error('Missing private key parameter');\n    }\n    const messageHash = version === SignTypedDataVersion.V1\n        ? _typedSignatureHash(data)\n        : exports.TypedDataUtils.eip712Hash(data, version);\n    const sig = (0, util_1.ecsign)(messageHash, privateKey);\n    return (0, utils_3.concatSig)((0, util_1.arrToBufArr)((0, utils_2.bigIntToBytes)(sig.v)), sig.r, sig.s);\n}\nexports.signTypedData = signTypedData;\n/**\n * Recover the address of the account that created the given EIP-712\n * signature. The version provided must match the version used to\n * create the signature.\n *\n * @param options - The signature recovery options.\n * @param options.data - The typed data that was signed.\n * @param options.signature - The '0x-prefixed hex encoded message signature.\n * @param options.version - The signing version to use.\n * @returns The '0x'-prefixed hex address of the signer.\n */\nfunction recoverTypedSignature({ data, signature, version, }) {\n    validateVersion(version);\n    if ((0, utils_3.isNullish)(data)) {\n        throw new Error('Missing data parameter');\n    }\n    else if ((0, utils_3.isNullish)(signature)) {\n        throw new Error('Missing signature parameter');\n    }\n    const messageHash = version === SignTypedDataVersion.V1\n        ? _typedSignatureHash(data)\n        : exports.TypedDataUtils.eip712Hash(data, version);\n    const publicKey = (0, utils_3.recoverPublicKey)(messageHash, signature);\n    const sender = (0, util_1.publicToAddress)(publicKey);\n    return (0, utils_2.bytesToHex)(sender);\n}\nexports.recoverTypedSignature = recoverTypedSignature;\n//# sourceMappingURL=sign-typed-data.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BtZXRhbWFzaytldGgtc2lnLXV0aWxANy4wLjIvbm9kZV9tb2R1bGVzL0BtZXRhbWFzay9ldGgtc2lnLXV0aWwvZGlzdC9zaWduLXR5cGVkLWRhdGEuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsNkJBQTZCLEdBQUcscUJBQXFCLEdBQUcsMEJBQTBCLEdBQUcsc0JBQXNCLEdBQUcsNEJBQTRCLEdBQUcsNEJBQTRCO0FBQ3pLLGVBQWUsbUJBQU8sQ0FBQywySEFBa0I7QUFDekMsb0JBQW9CLG1CQUFPLENBQUMsb0lBQXFCO0FBQ2pELGtCQUFrQixtQkFBTyxDQUFDLHlKQUFrQztBQUM1RCxnQkFBZ0IsbUJBQU8sQ0FBQyxxSkFBZ0M7QUFDeEQsZ0JBQWdCLG1CQUFPLENBQUMseUhBQWlCO0FBQ3pDLGlCQUFpQixtQkFBTyxDQUFDLDZJQUE4QjtBQUN2RCxnQkFBZ0IsbUJBQU8sQ0FBQyw4SEFBUztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQywwREFBMEQsNEJBQTRCLEtBQUs7QUFDNUYsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxnQkFBZ0I7QUFDaEQsZ0NBQWdDLGdCQUFnQjtBQUNoRCxxQkFBcUI7QUFDckI7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiLFNBQVM7QUFDVCx1QkFBdUIsZ0JBQWdCO0FBQ3ZDLGtCQUFrQixnQkFBZ0I7QUFDbEMsbUJBQW1CLGdCQUFnQjtBQUNuQyxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxRQUFRO0FBQ3JEO0FBQ0E7QUFDQSw4REFBOEQsUUFBUSwyQkFBMkIsMkJBQTJCO0FBQzVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0lBQWdJLE1BQU07QUFDdEk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0hBQWdILE1BQU0sOEJBQThCLEtBQUs7QUFDeko7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixvQkFBb0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsTUFBTSxVQUFVLEtBQUs7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUVBQXFFO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQsS0FBSztBQUNsRTtBQUNBLHFCQUFxQixLQUFLLEdBQUc7QUFDN0Isb0JBQW9CLGVBQWUsUUFBUSxHQUFHLEVBQUUsS0FBSztBQUNyRCx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQsNEJBQTRCO0FBQzFGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxrQkFBa0I7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksU0FBUztBQUNyQix5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLG1CQUFtQjtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxtREFBbUQ7QUFDcEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsUUFBUSxFQUFFLE9BQU87QUFDbkMsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLDRCQUE0QjtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLDJCQUEyQjtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQGNvbGxlY3RpYmxlL3dlYi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vQG1ldGFtYXNrK2V0aC1zaWctdXRpbEA3LjAuMi9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL2V0aC1zaWctdXRpbC9kaXN0L3NpZ24tdHlwZWQtZGF0YS5qcz82NzFhIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5yZWNvdmVyVHlwZWRTaWduYXR1cmUgPSBleHBvcnRzLnNpZ25UeXBlZERhdGEgPSBleHBvcnRzLnR5cGVkU2lnbmF0dXJlSGFzaCA9IGV4cG9ydHMuVHlwZWREYXRhVXRpbHMgPSBleHBvcnRzLlRZUEVEX01FU1NBR0VfU0NIRU1BID0gZXhwb3J0cy5TaWduVHlwZWREYXRhVmVyc2lvbiA9IHZvaWQgMDtcbmNvbnN0IHV0aWxfMSA9IHJlcXVpcmUoXCJAZXRoZXJldW1qcy91dGlsXCIpO1xuY29uc3QgYWJpX3V0aWxzXzEgPSByZXF1aXJlKFwiQG1ldGFtYXNrL2FiaS11dGlsc1wiKTtcbmNvbnN0IHBhcnNlcnNfMSA9IHJlcXVpcmUoXCJAbWV0YW1hc2svYWJpLXV0aWxzL2Rpc3QvcGFyc2Vyc1wiKTtcbmNvbnN0IHV0aWxzXzEgPSByZXF1aXJlKFwiQG1ldGFtYXNrL2FiaS11dGlscy9kaXN0L3V0aWxzXCIpO1xuY29uc3QgdXRpbHNfMiA9IHJlcXVpcmUoXCJAbWV0YW1hc2svdXRpbHNcIik7XG5jb25zdCBrZWNjYWtfMSA9IHJlcXVpcmUoXCJldGhlcmV1bS1jcnlwdG9ncmFwaHkva2VjY2FrXCIpO1xuY29uc3QgdXRpbHNfMyA9IHJlcXVpcmUoXCIuL3V0aWxzXCIpO1xuLyoqXG4gKiBSZXByZXNlbnRzIHRoZSB2ZXJzaW9uIG9mIGBzaWduVHlwZWREYXRhYCBiZWluZyB1c2VkLlxuICpcbiAqIFYxIGlzIGJhc2VkIHVwb24gW2FuIGVhcmx5IHZlcnNpb24gb2ZcbiAqIEVJUC03MTJdKGh0dHBzOi8vZ2l0aHViLmNvbS9ldGhlcmV1bS9FSVBzL3B1bGwvNzEyL2NvbW1pdHMvMjFhYmUyNTRmZTA0NTJkODU4M2Q1YjEzMmIxZDdiZTg3YzA0MzljYSlcbiAqIHRoYXQgbGFja2VkIHNvbWUgbGF0ZXIgc2VjdXJpdHkgaW1wcm92ZW1lbnRzLCBhbmQgc2hvdWxkIGdlbmVyYWxseSBiZSBuZWdsZWN0ZWQgaW4gZmF2b3Igb2ZcbiAqIGxhdGVyIHZlcnNpb25zLlxuICpcbiAqIFYzIGlzIGJhc2VkIG9uIEVJUC03MTIsIGV4Y2VwdCB0aGF0IGFycmF5cyBhbmQgcmVjdXJzaXZlIGRhdGEgc3RydWN0dXJlcyBhcmUgbm90IHN1cHBvcnRlZC5cbiAqXG4gKiBWNCBpcyBiYXNlZCBvbiBFSVAtNzEyLCBhbmQgaW5jbHVkZXMgZnVsbCBzdXBwb3J0IG9mIGFycmF5cyBhbmQgcmVjdXJzaXZlIGRhdGEgc3RydWN0dXJlcy5cbiAqL1xudmFyIFNpZ25UeXBlZERhdGFWZXJzaW9uO1xuKGZ1bmN0aW9uIChTaWduVHlwZWREYXRhVmVyc2lvbikge1xuICAgIFNpZ25UeXBlZERhdGFWZXJzaW9uW1wiVjFcIl0gPSBcIlYxXCI7XG4gICAgU2lnblR5cGVkRGF0YVZlcnNpb25bXCJWM1wiXSA9IFwiVjNcIjtcbiAgICBTaWduVHlwZWREYXRhVmVyc2lvbltcIlY0XCJdID0gXCJWNFwiO1xufSkoU2lnblR5cGVkRGF0YVZlcnNpb24gPSBleHBvcnRzLlNpZ25UeXBlZERhdGFWZXJzaW9uIHx8IChleHBvcnRzLlNpZ25UeXBlZERhdGFWZXJzaW9uID0ge30pKTtcbmV4cG9ydHMuVFlQRURfTUVTU0FHRV9TQ0hFTUEgPSB7XG4gICAgdHlwZTogJ29iamVjdCcsXG4gICAgcHJvcGVydGllczoge1xuICAgICAgICB0eXBlczoge1xuICAgICAgICAgICAgdHlwZTogJ29iamVjdCcsXG4gICAgICAgICAgICBhZGRpdGlvbmFsUHJvcGVydGllczoge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdhcnJheScsXG4gICAgICAgICAgICAgICAgaXRlbXM6IHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ29iamVjdCcsXG4gICAgICAgICAgICAgICAgICAgIHByb3BlcnRpZXM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IHsgdHlwZTogJ3N0cmluZycgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IHsgdHlwZTogJ3N0cmluZycgfSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgcmVxdWlyZWQ6IFsnbmFtZScsICd0eXBlJ10sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICAgIHByaW1hcnlUeXBlOiB7IHR5cGU6ICdzdHJpbmcnIH0sXG4gICAgICAgIGRvbWFpbjogeyB0eXBlOiAnb2JqZWN0JyB9LFxuICAgICAgICBtZXNzYWdlOiB7IHR5cGU6ICdvYmplY3QnIH0sXG4gICAgfSxcbiAgICByZXF1aXJlZDogWyd0eXBlcycsICdwcmltYXJ5VHlwZScsICdkb21haW4nLCAnbWVzc2FnZSddLFxufTtcbi8qKlxuICogVmFsaWRhdGUgdGhhdCB0aGUgZ2l2ZW4gdmFsdWUgaXMgYSB2YWxpZCB2ZXJzaW9uIHN0cmluZy5cbiAqXG4gKiBAcGFyYW0gdmVyc2lvbiAtIFRoZSB2ZXJzaW9uIHZhbHVlIHRvIHZhbGlkYXRlLlxuICogQHBhcmFtIGFsbG93ZWRWZXJzaW9ucyAtIEEgbGlzdCBvZiBhbGxvd2VkIHZlcnNpb25zLiBJZiBvbWl0dGVkLCBhbGwgdmVyc2lvbnMgYXJlIGFzc3VtZWQgdG8gYmVcbiAqIGFsbG93ZWQuXG4gKi9cbmZ1bmN0aW9uIHZhbGlkYXRlVmVyc2lvbih2ZXJzaW9uLCBhbGxvd2VkVmVyc2lvbnMpIHtcbiAgICBpZiAoIU9iamVjdC5rZXlzKFNpZ25UeXBlZERhdGFWZXJzaW9uKS5pbmNsdWRlcyh2ZXJzaW9uKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgdmVyc2lvbjogJyR7dmVyc2lvbn0nYCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGFsbG93ZWRWZXJzaW9ucyAmJiAhYWxsb3dlZFZlcnNpb25zLmluY2x1ZGVzKHZlcnNpb24pKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgU2lnblR5cGVkRGF0YVZlcnNpb24gbm90IGFsbG93ZWQ6ICcke3ZlcnNpb259Jy4gQWxsb3dlZCB2ZXJzaW9ucyBhcmU6ICR7YWxsb3dlZFZlcnNpb25zLmpvaW4oJywgJyl9YCk7XG4gICAgfVxufVxuLyoqXG4gKiBQYXJzZSBhIHN0cmluZywgbnVtYmVyLCBvciBiaWdpbnQgdmFsdWUgaW50byBhIGBVaW50OEFycmF5YC5cbiAqXG4gKiBAcGFyYW0gdHlwZSAtIFRoZSB0eXBlIG9mIHRoZSB2YWx1ZS5cbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBwYXJzZS5cbiAqIEByZXR1cm5zIFRoZSBwYXJzZWQgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIHBhcnNlTnVtYmVyKHR5cGUsIHZhbHVlKSB7XG4gICAgKDAsIHV0aWxzXzIuYXNzZXJ0KSh2YWx1ZSAhPT0gbnVsbCwgYFVuYWJsZSB0byBlbmNvZGUgdmFsdWU6IEludmFsaWQgbnVtYmVyLiBFeHBlY3RlZCBhIHZhbGlkIG51bWJlciB2YWx1ZSwgYnV0IHJlY2VpdmVkIFwiJHt2YWx1ZX1cIi5gKTtcbiAgICBjb25zdCBiaWdJbnRWYWx1ZSA9IEJpZ0ludCh2YWx1ZSk7XG4gICAgY29uc3QgbGVuZ3RoID0gKDAsIHBhcnNlcnNfMS5nZXRMZW5ndGgpKHR5cGUpO1xuICAgIGNvbnN0IG1heFZhbHVlID0gQmlnSW50KDIpICoqIEJpZ0ludChsZW5ndGgpIC0gQmlnSW50KDEpO1xuICAgIC8vIE5vdGUgdGhhdCB0aGlzIGlzIG5vdCBhY2N1cmF0ZSwgc2luY2UgdGhlIGFjdHVhbCBtYXhpbXVtIHZhbHVlIGZvciB1bnNpZ25lZFxuICAgIC8vIGludGVnZXJzIGlzIGAyIF4gKGxlbmd0aCAtIDEpIC0gMWAsIGJ1dCB0aGlzIGlzIHJlcXVpcmVkIGZvciBiYWNrd2FyZHNcbiAgICAvLyBjb21wYXRpYmlsaXR5IHdpdGggdGhlIG9sZCBpbXBsZW1lbnRhdGlvbi5cbiAgICAoMCwgdXRpbHNfMi5hc3NlcnQpKGJpZ0ludFZhbHVlID49IC1tYXhWYWx1ZSAmJiBiaWdJbnRWYWx1ZSA8PSBtYXhWYWx1ZSwgYFVuYWJsZSB0byBlbmNvZGUgdmFsdWU6IE51bWJlciBcIiR7dmFsdWV9XCIgaXMgb3V0IG9mIHJhbmdlIGZvciB0eXBlIFwiJHt0eXBlfVwiLmApO1xuICAgIHJldHVybiBiaWdJbnRWYWx1ZTtcbn1cbi8qKlxuICogUGFyc2UgYW4gYWRkcmVzcyBzdHJpbmcgdG8gYSBgVWludDhBcnJheWAuIFRoZSBiZWhhdmlvdXIgb2YgdGhpcyBpcyBxdWl0ZVxuICogc3RyYW5nZSwgaW4gdGhhdCBpdCBkb2VzIG5vdCBwYXJzZSB0aGUgYWRkcmVzcyBhcyBoZXhhZGVjaW1hbCBzdHJpbmcsIG5vciBhc1xuICogVVRGLTguIEl0IGRvZXMgc29tZSB3ZWlyZCBzdHVmZiB3aXRoIHRoZSBzdHJpbmcgYW5kIGNoYXIgY29kZXMsIGFuZCB0aGVuXG4gKiByZXR1cm5zIHRoZSByZXN1bHQgYXMgYSBgVWludDhBcnJheWAuXG4gKlxuICogVGhpcyBpcyBiYXNlZCBvbiB0aGUgb2xkIGBldGhlcmV1bWpzLWFiaWAgaW1wbGVtZW50YXRpb24sIHdoaWNoIGVzc2VudGlhbGx5XG4gKiBjYWxscyBgbmV3IEJOKGFkZHJlc3MsIDEwKWAgb24gdGhlIGFkZHJlc3Mgc3RyaW5nLCB0aGUgZXF1aXZhbGVudCBvZiBjYWxsaW5nXG4gKiBgcGFyc2VJbnQoYWRkcmVzcywgMTApYCBpbiBKYXZhU2NyaXB0LiBUaGlzIGlzIG5vdCBhIHZhbGlkIHdheSB0byBwYXJzZSBhblxuICogYWRkcmVzcyBhbmQgd291bGQgcmVzdWx0IGluIGBOYU5gIGluIHBsYWluIEphdmFTY3JpcHQsIGJ1dCBpdCBpcyB0aGVcbiAqIGJlaGF2aW91ciBvZiB0aGUgb2xkIGltcGxlbWVudGF0aW9uLCBhbmQgc28gd2UgbXVzdCBwcmVzZXJ2ZSBpdCBmb3IgYmFja3dhcmRzXG4gKiBjb21wYXRpYmlsaXR5LlxuICpcbiAqIEBwYXJhbSBhZGRyZXNzIC0gVGhlIGFkZHJlc3MgdG8gcGFyc2UuXG4gKiBAcmV0dXJucyBUaGUgcGFyc2VkIGFkZHJlc3MuXG4gKi9cbmZ1bmN0aW9uIHJlYWxseVN0cmFuZ2VBZGRyZXNzVG9CeXRlcyhhZGRyZXNzKSB7XG4gICAgbGV0IGFkZHJlc3NWYWx1ZSA9IEJpZ0ludCgwKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFkZHJlc3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgY2hhcmFjdGVyID0gQmlnSW50KGFkZHJlc3MuY2hhckNvZGVBdChpKSAtIDQ4KTtcbiAgICAgICAgYWRkcmVzc1ZhbHVlICo9IEJpZ0ludCgxMCk7XG4gICAgICAgIC8vICdhJ1xuICAgICAgICBpZiAoY2hhcmFjdGVyID49IDQ5KSB7XG4gICAgICAgICAgICBhZGRyZXNzVmFsdWUgKz0gY2hhcmFjdGVyIC0gQmlnSW50KDQ5KSArIEJpZ0ludCgweGEpO1xuICAgICAgICAgICAgLy8gJ0EnXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY2hhcmFjdGVyID49IDE3KSB7XG4gICAgICAgICAgICBhZGRyZXNzVmFsdWUgKz0gY2hhcmFjdGVyIC0gQmlnSW50KDE3KSArIEJpZ0ludCgweGEpO1xuICAgICAgICAgICAgLy8gJzAnIC0gJzknXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBhZGRyZXNzVmFsdWUgKz0gY2hhcmFjdGVyO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiAoMCwgdXRpbHNfMS5wYWRTdGFydCkoKDAsIHV0aWxzXzIuYmlnSW50VG9CeXRlcykoYWRkcmVzc1ZhbHVlKSwgMjApO1xufVxuLyoqXG4gKiBFbmNvZGUgYSBzaW5nbGUgZmllbGQuXG4gKlxuICogQHBhcmFtIHR5cGVzIC0gQWxsIHR5cGUgZGVmaW5pdGlvbnMuXG4gKiBAcGFyYW0gbmFtZSAtIFRoZSBuYW1lIG9mIHRoZSBmaWVsZCB0byBlbmNvZGUuXG4gKiBAcGFyYW0gdHlwZSAtIFRoZSB0eXBlIG9mIHRoZSBmaWVsZCBiZWluZyBlbmNvZGVkLlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIGVuY29kZS5cbiAqIEBwYXJhbSB2ZXJzaW9uIC0gVGhlIEVJUC03MTIgdmVyc2lvbiB0aGUgZW5jb2Rpbmcgc2hvdWxkIGNvbXBseSB3aXRoLlxuICogQHJldHVybnMgRW5jb2RlZCByZXByZXNlbnRhdGlvbiBvZiB0aGUgZmllbGQuXG4gKi9cbmZ1bmN0aW9uIGVuY29kZUZpZWxkKHR5cGVzLCBuYW1lLCB0eXBlLCBcbi8vIFRPRE86IGNvbnN0cmFpbiB0eXBlIG9uIGB2YWx1ZWBcbnZhbHVlLCB2ZXJzaW9uKSB7XG4gICAgdmFsaWRhdGVWZXJzaW9uKHZlcnNpb24sIFtTaWduVHlwZWREYXRhVmVyc2lvbi5WMywgU2lnblR5cGVkRGF0YVZlcnNpb24uVjRdKTtcbiAgICBpZiAodHlwZXNbdHlwZV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgJ2J5dGVzMzInLFxuICAgICAgICAgICAgLy8gVE9ETzogcmV0dXJuIEJ1ZmZlciwgcmVtb3ZlIHN0cmluZyBmcm9tIHJldHVybiB0eXBlXG4gICAgICAgICAgICB2ZXJzaW9uID09PSBTaWduVHlwZWREYXRhVmVyc2lvbi5WNCAmJiB2YWx1ZSA9PSBudWxsIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tZXEtbnVsbFxuICAgICAgICAgICAgICAgID8gJzB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCdcbiAgICAgICAgICAgICAgICA6ICgwLCB1dGlsXzEuYXJyVG9CdWZBcnIpKCgwLCBrZWNjYWtfMS5rZWNjYWsyNTYpKGVuY29kZURhdGEodHlwZSwgdmFsdWUsIHR5cGVzLCB2ZXJzaW9uKSkpLFxuICAgICAgICBdO1xuICAgIH1cbiAgICAvLyBgZnVuY3Rpb25gIGlzIHN1cHBvcnRlZCBpbiBgQG1ldGFtYXNrL2FiaS11dGlsc2AsIGJ1dCBub3QgYWxsb3dlZCBieVxuICAgIC8vIEVJUC03MTIsIHNvIHdlIHRocm93IGFuIGVycm9yIGhlcmUuXG4gICAgaWYgKHR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbnN1cHBvcnRlZCBvciBpbnZhbGlkIHR5cGU6IFwiZnVuY3Rpb25cIicpO1xuICAgIH1cbiAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYG1pc3NpbmcgdmFsdWUgZm9yIGZpZWxkICR7bmFtZX0gb2YgdHlwZSAke3R5cGV9YCk7XG4gICAgfVxuICAgIGlmICh0eXBlID09PSAnYWRkcmVzcycpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIHJldHVybiBbJ2FkZHJlc3MnLCAoMCwgdXRpbHNfMS5wYWRTdGFydCkoKDAsIHV0aWxzXzIubnVtYmVyVG9CeXRlcykodmFsdWUpLCAyMCldO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCgwLCB1dGlsc18yLmlzU3RyaWN0SGV4U3RyaW5nKSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBbJ2FkZHJlc3MnLCAoMCwgdXRpbHNfMi5hZGQweCkodmFsdWUpXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICByZXR1cm4gWydhZGRyZXNzJywgcmVhbGx5U3RyYW5nZUFkZHJlc3NUb0J5dGVzKHZhbHVlKS5zdWJhcnJheSgwLCAyMCldO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmICh0eXBlID09PSAnYm9vbCcpIHtcbiAgICAgICAgcmV0dXJuIFsnYm9vbCcsIEJvb2xlYW4odmFsdWUpXTtcbiAgICB9XG4gICAgaWYgKHR5cGUgPT09ICdieXRlcycpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIHZhbHVlID0gKDAsIHV0aWxzXzIubnVtYmVyVG9CeXRlcykodmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCgwLCB1dGlsc18yLmlzU3RyaWN0SGV4U3RyaW5nKSh2YWx1ZSkgfHwgdmFsdWUgPT09ICcweCcpIHtcbiAgICAgICAgICAgIHZhbHVlID0gKDAsIHV0aWxzXzIuaGV4VG9CeXRlcykodmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHZhbHVlID0gKDAsIHV0aWxzXzIuc3RyaW5nVG9CeXRlcykodmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbJ2J5dGVzMzInLCAoMCwgdXRpbF8xLmFyclRvQnVmQXJyKSgoMCwga2VjY2FrXzEua2VjY2FrMjU2KSh2YWx1ZSkpXTtcbiAgICB9XG4gICAgaWYgKHR5cGUuc3RhcnRzV2l0aCgnYnl0ZXMnKSAmJiB0eXBlICE9PSAnYnl0ZXMnICYmICF0eXBlLmluY2x1ZGVzKCdbJykpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZSA8IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gWydieXRlczMyJywgbmV3IFVpbnQ4QXJyYXkoMzIpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBbJ2J5dGVzMzInLCAoMCwgdXRpbHNfMi5iaWdJbnRUb0J5dGVzKShCaWdJbnQodmFsdWUpKV07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoKDAsIHV0aWxzXzIuaXNTdHJpY3RIZXhTdHJpbmcpKHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIFsnYnl0ZXMzMicsICgwLCB1dGlsc18yLmhleFRvQnl0ZXMpKHZhbHVlKV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFsnYnl0ZXMzMicsIHZhbHVlXTtcbiAgICB9XG4gICAgaWYgKHR5cGUuc3RhcnRzV2l0aCgnaW50JykgJiYgIXR5cGUuaW5jbHVkZXMoJ1snKSkge1xuICAgICAgICBjb25zdCBiaWdJbnRWYWx1ZSA9IHBhcnNlTnVtYmVyKHR5cGUsIHZhbHVlKTtcbiAgICAgICAgaWYgKGJpZ0ludFZhbHVlID49IEJpZ0ludCgwKSkge1xuICAgICAgICAgICAgcmV0dXJuIFsndWludDI1NicsIGJpZ0ludFZhbHVlXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gWydpbnQyNTYnLCBiaWdJbnRWYWx1ZV07XG4gICAgfVxuICAgIGlmICh0eXBlID09PSAnc3RyaW5nJykge1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgdmFsdWUgPSAoMCwgdXRpbHNfMi5udW1iZXJUb0J5dGVzKSh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YWx1ZSA9ICgwLCB1dGlsc18yLnN0cmluZ1RvQnl0ZXMpKHZhbHVlICE9PSBudWxsICYmIHZhbHVlICE9PSB2b2lkIDAgPyB2YWx1ZSA6ICcnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gWydieXRlczMyJywgKDAsIHV0aWxfMS5hcnJUb0J1ZkFycikoKDAsIGtlY2Nha18xLmtlY2NhazI1NikodmFsdWUpKV07XG4gICAgfVxuICAgIGlmICh0eXBlLmVuZHNXaXRoKCddJykpIHtcbiAgICAgICAgaWYgKHZlcnNpb24gPT09IFNpZ25UeXBlZERhdGFWZXJzaW9uLlYzKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0FycmF5cyBhcmUgdW5pbXBsZW1lbnRlZCBpbiBlbmNvZGVEYXRhOyB1c2UgVjQgZXh0ZW5zaW9uJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcGFyc2VkVHlwZSA9IHR5cGUuc2xpY2UoMCwgdHlwZS5sYXN0SW5kZXhPZignWycpKTtcbiAgICAgICAgY29uc3QgdHlwZVZhbHVlUGFpcnMgPSB2YWx1ZS5tYXAoKGl0ZW0pID0+IGVuY29kZUZpZWxkKHR5cGVzLCBuYW1lLCBwYXJzZWRUeXBlLCBpdGVtLCB2ZXJzaW9uKSk7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAnYnl0ZXMzMicsXG4gICAgICAgICAgICAoMCwgdXRpbF8xLmFyclRvQnVmQXJyKSgoMCwga2VjY2FrXzEua2VjY2FrMjU2KSgoMCwgYWJpX3V0aWxzXzEuZW5jb2RlKSh0eXBlVmFsdWVQYWlycy5tYXAoKFt0XSkgPT4gdCksIHR5cGVWYWx1ZVBhaXJzLm1hcCgoWywgdl0pID0+IHYpKSkpLFxuICAgICAgICBdO1xuICAgIH1cbiAgICByZXR1cm4gW3R5cGUsIHZhbHVlXTtcbn1cbi8qKlxuICogRW5jb2RlcyBhbiBvYmplY3QgYnkgZW5jb2RpbmcgYW5kIGNvbmNhdGVuYXRpbmcgZWFjaCBvZiBpdHMgbWVtYmVycy5cbiAqXG4gKiBAcGFyYW0gcHJpbWFyeVR5cGUgLSBUaGUgcm9vdCB0eXBlLlxuICogQHBhcmFtIGRhdGEgLSBUaGUgb2JqZWN0IHRvIGVuY29kZS5cbiAqIEBwYXJhbSB0eXBlcyAtIFR5cGUgZGVmaW5pdGlvbnMgZm9yIGFsbCB0eXBlcyBpbmNsdWRlZCBpbiB0aGUgbWVzc2FnZS5cbiAqIEBwYXJhbSB2ZXJzaW9uIC0gVGhlIEVJUC03MTIgdmVyc2lvbiB0aGUgZW5jb2Rpbmcgc2hvdWxkIGNvbXBseSB3aXRoLlxuICogQHJldHVybnMgQW4gZW5jb2RlZCByZXByZXNlbnRhdGlvbiBvZiBhbiBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIGVuY29kZURhdGEocHJpbWFyeVR5cGUsIGRhdGEsIHR5cGVzLCB2ZXJzaW9uKSB7XG4gICAgdmFsaWRhdGVWZXJzaW9uKHZlcnNpb24sIFtTaWduVHlwZWREYXRhVmVyc2lvbi5WMywgU2lnblR5cGVkRGF0YVZlcnNpb24uVjRdKTtcbiAgICBjb25zdCBlbmNvZGVkVHlwZXMgPSBbJ2J5dGVzMzInXTtcbiAgICBjb25zdCBlbmNvZGVkVmFsdWVzID0gW1xuICAgICAgICBoYXNoVHlwZShwcmltYXJ5VHlwZSwgdHlwZXMpLFxuICAgIF07XG4gICAgZm9yIChjb25zdCBmaWVsZCBvZiB0eXBlc1twcmltYXJ5VHlwZV0pIHtcbiAgICAgICAgaWYgKHZlcnNpb24gPT09IFNpZ25UeXBlZERhdGFWZXJzaW9uLlYzICYmIGRhdGFbZmllbGQubmFtZV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgW3R5cGUsIHZhbHVlXSA9IGVuY29kZUZpZWxkKHR5cGVzLCBmaWVsZC5uYW1lLCBmaWVsZC50eXBlLCBkYXRhW2ZpZWxkLm5hbWVdLCB2ZXJzaW9uKTtcbiAgICAgICAgZW5jb2RlZFR5cGVzLnB1c2godHlwZSk7XG4gICAgICAgIGVuY29kZWRWYWx1ZXMucHVzaCh2YWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiAoMCwgdXRpbF8xLmFyclRvQnVmQXJyKSgoMCwgYWJpX3V0aWxzXzEuZW5jb2RlKShlbmNvZGVkVHlwZXMsIGVuY29kZWRWYWx1ZXMpKTtcbn1cbi8qKlxuICogRW5jb2RlcyB0aGUgdHlwZSBvZiBhbiBvYmplY3QgYnkgZW5jb2RpbmcgYSBjb21tYSBkZWxpbWl0ZWQgbGlzdCBvZiBpdHMgbWVtYmVycy5cbiAqXG4gKiBAcGFyYW0gcHJpbWFyeVR5cGUgLSBUaGUgcm9vdCB0eXBlIHRvIGVuY29kZS5cbiAqIEBwYXJhbSB0eXBlcyAtIFR5cGUgZGVmaW5pdGlvbnMgZm9yIGFsbCB0eXBlcyBpbmNsdWRlZCBpbiB0aGUgbWVzc2FnZS5cbiAqIEByZXR1cm5zIEFuIGVuY29kZWQgcmVwcmVzZW50YXRpb24gb2YgdGhlIHByaW1hcnkgdHlwZS5cbiAqL1xuZnVuY3Rpb24gZW5jb2RlVHlwZShwcmltYXJ5VHlwZSwgdHlwZXMpIHtcbiAgICBsZXQgcmVzdWx0ID0gJyc7XG4gICAgY29uc3QgdW5zb3J0ZWREZXBzID0gZmluZFR5cGVEZXBlbmRlbmNpZXMocHJpbWFyeVR5cGUsIHR5cGVzKTtcbiAgICB1bnNvcnRlZERlcHMuZGVsZXRlKHByaW1hcnlUeXBlKTtcbiAgICBjb25zdCBkZXBzID0gW3ByaW1hcnlUeXBlLCAuLi5BcnJheS5mcm9tKHVuc29ydGVkRGVwcykuc29ydCgpXTtcbiAgICBmb3IgKGNvbnN0IHR5cGUgb2YgZGVwcykge1xuICAgICAgICBjb25zdCBjaGlsZHJlbiA9IHR5cGVzW3R5cGVdO1xuICAgICAgICBpZiAoIWNoaWxkcmVuKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE5vIHR5cGUgZGVmaW5pdGlvbiBzcGVjaWZpZWQ6ICR7dHlwZX1gKTtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHQgKz0gYCR7dHlwZX0oJHt0eXBlc1t0eXBlXVxuICAgICAgICAgICAgLm1hcCgoeyBuYW1lLCB0eXBlOiB0IH0pID0+IGAke3R9ICR7bmFtZX1gKVxuICAgICAgICAgICAgLmpvaW4oJywnKX0pYDtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbi8qKlxuICogRmluZHMgYWxsIHR5cGVzIHdpdGhpbiBhIHR5cGUgZGVmaW5pdGlvbiBvYmplY3QuXG4gKlxuICogQHBhcmFtIHByaW1hcnlUeXBlIC0gVGhlIHJvb3QgdHlwZS5cbiAqIEBwYXJhbSB0eXBlcyAtIFR5cGUgZGVmaW5pdGlvbnMgZm9yIGFsbCB0eXBlcyBpbmNsdWRlZCBpbiB0aGUgbWVzc2FnZS5cbiAqIEBwYXJhbSByZXN1bHRzIC0gVGhlIGN1cnJlbnQgc2V0IG9mIGFjY3VtdWxhdGVkIHR5cGVzLlxuICogQHJldHVybnMgVGhlIHNldCBvZiBhbGwgdHlwZXMgZm91bmQgaW4gdGhlIHR5cGUgZGVmaW5pdGlvbi5cbiAqL1xuZnVuY3Rpb24gZmluZFR5cGVEZXBlbmRlbmNpZXMocHJpbWFyeVR5cGUsIHR5cGVzLCByZXN1bHRzID0gbmV3IFNldCgpKSB7XG4gICAgaWYgKHR5cGVvZiBwcmltYXJ5VHlwZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGZpbmRUeXBlRGVwZW5kZW5jaWVzIGlucHV0ICR7SlNPTi5zdHJpbmdpZnkocHJpbWFyeVR5cGUpfWApO1xuICAgIH1cbiAgICBjb25zdCBtYXRjaCA9IHByaW1hcnlUeXBlLm1hdGNoKC9eXFx3Ki91KTtcbiAgICBbcHJpbWFyeVR5cGVdID0gbWF0Y2g7XG4gICAgaWYgKHJlc3VsdHMuaGFzKHByaW1hcnlUeXBlKSB8fCB0eXBlc1twcmltYXJ5VHlwZV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICB9XG4gICAgcmVzdWx0cy5hZGQocHJpbWFyeVR5cGUpO1xuICAgIGZvciAoY29uc3QgZmllbGQgb2YgdHlwZXNbcHJpbWFyeVR5cGVdKSB7XG4gICAgICAgIGZpbmRUeXBlRGVwZW5kZW5jaWVzKGZpZWxkLnR5cGUsIHR5cGVzLCByZXN1bHRzKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdHM7XG59XG4vKipcbiAqIEhhc2hlcyBhbiBvYmplY3QuXG4gKlxuICogQHBhcmFtIHByaW1hcnlUeXBlIC0gVGhlIHJvb3QgdHlwZS5cbiAqIEBwYXJhbSBkYXRhIC0gVGhlIG9iamVjdCB0byBoYXNoLlxuICogQHBhcmFtIHR5cGVzIC0gVHlwZSBkZWZpbml0aW9ucyBmb3IgYWxsIHR5cGVzIGluY2x1ZGVkIGluIHRoZSBtZXNzYWdlLlxuICogQHBhcmFtIHZlcnNpb24gLSBUaGUgRUlQLTcxMiB2ZXJzaW9uIHRoZSBlbmNvZGluZyBzaG91bGQgY29tcGx5IHdpdGguXG4gKiBAcmV0dXJucyBUaGUgaGFzaCBvZiB0aGUgb2JqZWN0LlxuICovXG5mdW5jdGlvbiBoYXNoU3RydWN0KHByaW1hcnlUeXBlLCBkYXRhLCB0eXBlcywgdmVyc2lvbikge1xuICAgIHZhbGlkYXRlVmVyc2lvbih2ZXJzaW9uLCBbU2lnblR5cGVkRGF0YVZlcnNpb24uVjMsIFNpZ25UeXBlZERhdGFWZXJzaW9uLlY0XSk7XG4gICAgY29uc3QgZW5jb2RlZCA9IGVuY29kZURhdGEocHJpbWFyeVR5cGUsIGRhdGEsIHR5cGVzLCB2ZXJzaW9uKTtcbiAgICBjb25zdCBoYXNoZWQgPSAoMCwga2VjY2FrXzEua2VjY2FrMjU2KShlbmNvZGVkKTtcbiAgICBjb25zdCBidWYgPSAoMCwgdXRpbF8xLmFyclRvQnVmQXJyKShoYXNoZWQpO1xuICAgIHJldHVybiBidWY7XG59XG4vKipcbiAqIEhhc2hlcyB0aGUgdHlwZSBvZiBhbiBvYmplY3QuXG4gKlxuICogQHBhcmFtIHByaW1hcnlUeXBlIC0gVGhlIHJvb3QgdHlwZSB0byBoYXNoLlxuICogQHBhcmFtIHR5cGVzIC0gVHlwZSBkZWZpbml0aW9ucyBmb3IgYWxsIHR5cGVzIGluY2x1ZGVkIGluIHRoZSBtZXNzYWdlLlxuICogQHJldHVybnMgVGhlIGhhc2ggb2YgdGhlIG9iamVjdCB0eXBlLlxuICovXG5mdW5jdGlvbiBoYXNoVHlwZShwcmltYXJ5VHlwZSwgdHlwZXMpIHtcbiAgICBjb25zdCBlbmNvZGVkSGFzaFR5cGUgPSAoMCwgdXRpbHNfMi5zdHJpbmdUb0J5dGVzKShlbmNvZGVUeXBlKHByaW1hcnlUeXBlLCB0eXBlcykpO1xuICAgIHJldHVybiAoMCwgdXRpbF8xLmFyclRvQnVmQXJyKSgoMCwga2VjY2FrXzEua2VjY2FrMjU2KShlbmNvZGVkSGFzaFR5cGUpKTtcbn1cbi8qKlxuICogUmVtb3ZlcyBwcm9wZXJ0aWVzIGZyb20gYSBtZXNzYWdlIG9iamVjdCB0aGF0IGFyZSBub3QgZGVmaW5lZCBwZXIgRUlQLTcxMi5cbiAqXG4gKiBAcGFyYW0gZGF0YSAtIFRoZSB0eXBlZCBtZXNzYWdlIG9iamVjdC5cbiAqIEByZXR1cm5zIFRoZSB0eXBlZCBtZXNzYWdlIG9iamVjdCB3aXRoIG9ubHkgYWxsb3dlZCBmaWVsZHMuXG4gKi9cbmZ1bmN0aW9uIHNhbml0aXplRGF0YShkYXRhKSB7XG4gICAgY29uc3Qgc2FuaXRpemVkRGF0YSA9IHt9O1xuICAgIGZvciAoY29uc3Qga2V5IGluIGV4cG9ydHMuVFlQRURfTUVTU0FHRV9TQ0hFTUEucHJvcGVydGllcykge1xuICAgICAgICBpZiAoZGF0YVtrZXldKSB7XG4gICAgICAgICAgICBzYW5pdGl6ZWREYXRhW2tleV0gPSBkYXRhW2tleV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKCd0eXBlcycgaW4gc2FuaXRpemVkRGF0YSkge1xuICAgICAgICAvLyBUT0RPOiBGaXggdHlwZXNcbiAgICAgICAgc2FuaXRpemVkRGF0YS50eXBlcyA9IE9iamVjdC5hc3NpZ24oeyBFSVA3MTJEb21haW46IFtdIH0sIHNhbml0aXplZERhdGEudHlwZXMpO1xuICAgIH1cbiAgICByZXR1cm4gc2FuaXRpemVkRGF0YTtcbn1cbi8qKlxuICogQ3JlYXRlIGEgRUlQLTcxMiBEb21haW4gSGFzaC5cbiAqIFRoaXMgaGFzaCBpcyB1c2VkIGF0IHRoZSB0b3Agb2YgdGhlIEVJUC03MTIgZW5jb2RpbmcuXG4gKlxuICogQHBhcmFtIHR5cGVkRGF0YSAtIFRoZSB0eXBlZCBtZXNzYWdlIHRvIGhhc2guXG4gKiBAcGFyYW0gdmVyc2lvbiAtIFRoZSBFSVAtNzEyIHZlcnNpb24gdGhlIGVuY29kaW5nIHNob3VsZCBjb21wbHkgd2l0aC5cbiAqIEByZXR1cm5zIFRoZSBoYXNoIG9mIHRoZSBkb21haW4gb2JqZWN0LlxuICovXG5mdW5jdGlvbiBlaXA3MTJEb21haW5IYXNoKHR5cGVkRGF0YSwgdmVyc2lvbikge1xuICAgIHZhbGlkYXRlVmVyc2lvbih2ZXJzaW9uLCBbU2lnblR5cGVkRGF0YVZlcnNpb24uVjMsIFNpZ25UeXBlZERhdGFWZXJzaW9uLlY0XSk7XG4gICAgY29uc3Qgc2FuaXRpemVkRGF0YSA9IHNhbml0aXplRGF0YSh0eXBlZERhdGEpO1xuICAgIGNvbnN0IHsgZG9tYWluIH0gPSBzYW5pdGl6ZWREYXRhO1xuICAgIGNvbnN0IGRvbWFpblR5cGUgPSB7IEVJUDcxMkRvbWFpbjogc2FuaXRpemVkRGF0YS50eXBlcy5FSVA3MTJEb21haW4gfTtcbiAgICByZXR1cm4gaGFzaFN0cnVjdCgnRUlQNzEyRG9tYWluJywgZG9tYWluLCBkb21haW5UeXBlLCB2ZXJzaW9uKTtcbn1cbi8qKlxuICogSGFzaCBhIHR5cGVkIG1lc3NhZ2UgYWNjb3JkaW5nIHRvIEVJUC03MTIuIFRoZSByZXR1cm5lZCBtZXNzYWdlIHN0YXJ0cyB3aXRoIHRoZSBFSVAtNzEyIHByZWZpeCxcbiAqIHdoaWNoIGlzIFwiMTkwMVwiLCBmb2xsb3dlZCBieSB0aGUgaGFzaCBvZiB0aGUgZG9tYWluIHNlcGFyYXRvciwgdGhlbiB0aGUgZGF0YSAoaWYgYW55KS5cbiAqIFRoZSByZXN1bHQgaXMgaGFzaGVkIGFnYWluIGFuZCByZXR1cm5lZC5cbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIGRvZXMgbm90IHNpZ24gdGhlIG1lc3NhZ2UuIFRoZSByZXN1bHRpbmcgaGFzaCBtdXN0IHN0aWxsIGJlIHNpZ25lZCB0byBjcmVhdGUgYW5cbiAqIEVJUC03MTIgc2lnbmF0dXJlLlxuICpcbiAqIEBwYXJhbSB0eXBlZERhdGEgLSBUaGUgdHlwZWQgbWVzc2FnZSB0byBoYXNoLlxuICogQHBhcmFtIHZlcnNpb24gLSBUaGUgRUlQLTcxMiB2ZXJzaW9uIHRoZSBlbmNvZGluZyBzaG91bGQgY29tcGx5IHdpdGguXG4gKiBAcmV0dXJucyBUaGUgaGFzaCBvZiB0aGUgdHlwZWQgbWVzc2FnZS5cbiAqL1xuZnVuY3Rpb24gZWlwNzEySGFzaCh0eXBlZERhdGEsIHZlcnNpb24pIHtcbiAgICB2YWxpZGF0ZVZlcnNpb24odmVyc2lvbiwgW1NpZ25UeXBlZERhdGFWZXJzaW9uLlYzLCBTaWduVHlwZWREYXRhVmVyc2lvbi5WNF0pO1xuICAgIGNvbnN0IHNhbml0aXplZERhdGEgPSBzYW5pdGl6ZURhdGEodHlwZWREYXRhKTtcbiAgICBjb25zdCBwYXJ0cyA9IFsoMCwgdXRpbHNfMi5oZXhUb0J5dGVzKSgnMTkwMScpXTtcbiAgICBwYXJ0cy5wdXNoKGVpcDcxMkRvbWFpbkhhc2godHlwZWREYXRhLCB2ZXJzaW9uKSk7XG4gICAgaWYgKHNhbml0aXplZERhdGEucHJpbWFyeVR5cGUgIT09ICdFSVA3MTJEb21haW4nKSB7XG4gICAgICAgIHBhcnRzLnB1c2goaGFzaFN0cnVjdChcbiAgICAgICAgLy8gVE9ETzogVmFsaWRhdGUgdGhhdCB0aGlzIGlzIGEgc3RyaW5nLCBzbyB0aGlzIHR5cGUgY2FzdCBjYW4gYmUgcmVtb3ZlZC5cbiAgICAgICAgc2FuaXRpemVkRGF0YS5wcmltYXJ5VHlwZSwgc2FuaXRpemVkRGF0YS5tZXNzYWdlLCBzYW5pdGl6ZWREYXRhLnR5cGVzLCB2ZXJzaW9uKSk7XG4gICAgfVxuICAgIHJldHVybiAoMCwgdXRpbF8xLmFyclRvQnVmQXJyKSgoMCwga2VjY2FrXzEua2VjY2FrMjU2KSgoMCwgdXRpbHNfMi5jb25jYXRCeXRlcykocGFydHMpKSk7XG59XG4vKipcbiAqIEEgY29sbGVjdGlvbiBvZiB1dGlsaXR5IGZ1bmN0aW9ucyB1c2VkIGZvciBzaWduaW5nIHR5cGVkIGRhdGEuXG4gKi9cbmV4cG9ydHMuVHlwZWREYXRhVXRpbHMgPSB7XG4gICAgZW5jb2RlRGF0YSxcbiAgICBlbmNvZGVUeXBlLFxuICAgIGZpbmRUeXBlRGVwZW5kZW5jaWVzLFxuICAgIGhhc2hTdHJ1Y3QsXG4gICAgaGFzaFR5cGUsXG4gICAgc2FuaXRpemVEYXRhLFxuICAgIGVpcDcxMkhhc2gsXG4gICAgZWlwNzEyRG9tYWluSGFzaCxcbn07XG4vKipcbiAqIEdlbmVyYXRlIHRoZSBcIlYxXCIgaGFzaCBmb3IgdGhlIHByb3ZpZGVkIHR5cGVkIG1lc3NhZ2UuXG4gKlxuICogVGhlIGhhc2ggd2lsbCBiZSBnZW5lcmF0ZWQgaW4gYWNjb3JkYW5jZSB3aXRoIGFuIGVhcmxpZXIgdmVyc2lvbiBvZiB0aGUgRUlQLTcxMlxuICogc3BlY2lmaWNhdGlvbi4gVGhpcyBoYXNoIGlzIHVzZWQgaW4gYHNpZ25UeXBlZERhdGFfdjFgLlxuICpcbiAqIEBwYXJhbSB0eXBlZERhdGEgLSBUaGUgdHlwZWQgbWVzc2FnZS5cbiAqIEByZXR1cm5zIFRoZSAnMHgnLXByZWZpeGVkIGhleCBlbmNvZGVkIGhhc2ggcmVwcmVzZW50aW5nIHRoZSB0eXBlIG9mIHRoZSBwcm92aWRlZCBtZXNzYWdlLlxuICovXG5mdW5jdGlvbiB0eXBlZFNpZ25hdHVyZUhhc2godHlwZWREYXRhKSB7XG4gICAgY29uc3QgaGFzaEJ1ZmZlciA9IF90eXBlZFNpZ25hdHVyZUhhc2godHlwZWREYXRhKTtcbiAgICByZXR1cm4gKDAsIHV0aWxzXzIuYnl0ZXNUb0hleCkoaGFzaEJ1ZmZlcik7XG59XG5leHBvcnRzLnR5cGVkU2lnbmF0dXJlSGFzaCA9IHR5cGVkU2lnbmF0dXJlSGFzaDtcbi8qKlxuICogTm9ybWFsaXplIGEgdmFsdWUsIHNvIHRoYXQgYEBtZXRhbWFzay9hYmktdXRpbHNgIGNhbiBoYW5kbGUgaXQuIFRoaXNcbiAqIG1hdGNoZXMgdGhlIGJlaGF2aW91ciBvZiB0aGUgYGV0aGVyZXVtanMtYWJpYCBsaWJyYXJ5LlxuICpcbiAqIEBwYXJhbSB0eXBlIC0gVGhlIHR5cGUgb2YgdGhlIHZhbHVlIHRvIG5vcm1hbGl6ZS5cbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBub3JtYWxpemUuXG4gKiBAcmV0dXJucyBUaGUgbm9ybWFsaXplZCB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gbm9ybWFsaXplVmFsdWUodHlwZSwgdmFsdWUpIHtcbiAgICBpZiAoKDAsIHBhcnNlcnNfMS5pc0FycmF5VHlwZSkodHlwZSkgJiYgQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgY29uc3QgW2lubmVyVHlwZV0gPSAoMCwgcGFyc2Vyc18xLmdldEFycmF5VHlwZSkodHlwZSk7XG4gICAgICAgIHJldHVybiB2YWx1ZS5tYXAoKGl0ZW0pID0+IG5vcm1hbGl6ZVZhbHVlKGlubmVyVHlwZSwgaXRlbSkpO1xuICAgIH1cbiAgICBpZiAodHlwZSA9PT0gJ2FkZHJlc3MnKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICByZXR1cm4gKDAsIHV0aWxzXzEucGFkU3RhcnQpKCgwLCB1dGlsc18yLm51bWJlclRvQnl0ZXMpKHZhbHVlKSwgMjApO1xuICAgICAgICB9XG4gICAgICAgIGlmICgoMCwgdXRpbHNfMi5pc1N0cmljdEhleFN0cmluZykodmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gKDAsIHV0aWxzXzEucGFkU3RhcnQpKCgwLCB1dGlsc18yLmhleFRvQnl0ZXMpKHZhbHVlKS5zdWJhcnJheSgwLCAyMCksIDIwKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7XG4gICAgICAgICAgICByZXR1cm4gKDAsIHV0aWxzXzEucGFkU3RhcnQpKHZhbHVlLnN1YmFycmF5KDAsIDIwKSwgMjApO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmICh0eXBlID09PSAnYm9vbCcpIHtcbiAgICAgICAgcmV0dXJuIEJvb2xlYW4odmFsdWUpO1xuICAgIH1cbiAgICBpZiAodHlwZS5zdGFydHNXaXRoKCdieXRlcycpICYmIHR5cGUgIT09ICdieXRlcycpIHtcbiAgICAgICAgY29uc3QgbGVuZ3RoID0gKDAsIHBhcnNlcnNfMS5nZXRCeXRlTGVuZ3RoKSh0eXBlKTtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZSA8IDApIHtcbiAgICAgICAgICAgICAgICAvLyBgc29saWRpdHlQYWNrKFsnYnl0ZXNOJ10sIFstMV0pYCByZXR1cm5zIGAweDAwLi4wMGAuXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gKDAsIHV0aWxzXzIubnVtYmVyVG9CeXRlcykodmFsdWUpLnN1YmFycmF5KDAsIGxlbmd0aCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCgwLCB1dGlsc18yLmlzU3RyaWN0SGV4U3RyaW5nKSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiAoMCwgdXRpbHNfMi5oZXhUb0J5dGVzKSh2YWx1ZSkuc3ViYXJyYXkoMCwgbGVuZ3RoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWUuc3ViYXJyYXkoMCwgbGVuZ3RoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAodHlwZS5zdGFydHNXaXRoKCd1aW50JykpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLmFicyh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHR5cGUuc3RhcnRzV2l0aCgnaW50JykpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIGNvbnN0IGxlbmd0aCA9ICgwLCBwYXJzZXJzXzEuZ2V0TGVuZ3RoKSh0eXBlKTtcbiAgICAgICAgICAgIHJldHVybiBCaWdJbnQuYXNJbnROKGxlbmd0aCwgQmlnSW50KHZhbHVlKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xufVxuLyoqXG4gKiBGb3Igc29tZSByZWFzb24gYGV0aGVyZXVtanMtYWJpYCB0cmVhdHMgYGFkZHJlc3NgIGFuZCBgYWRkcmVzc1tdYCBkaWZmZXJlbnRseVxuICogc28gd2UgbmVlZCB0byBub3JtYWxpemUgYGFkZHJlc3NbXWAgZGlmZmVyZW50bHkuXG4gKlxuICogQHBhcmFtIHZhbHVlcyAtIFRoZSB2YWx1ZXMgdG8gbm9ybWFsaXplLlxuICogQHJldHVybnMgVGhlIG5vcm1hbGl6ZWQgdmFsdWVzLlxuICovXG5mdW5jdGlvbiBub3JtYWxpemVBZGRyZXNzZXModmFsdWVzKSB7XG4gICAgcmV0dXJuIHZhbHVlcy5tYXAoKHZhbHVlKSA9PiB7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICByZXR1cm4gKDAsIHV0aWxzXzEucGFkU3RhcnQpKCgwLCB1dGlsc18yLm51bWJlclRvQnl0ZXMpKHZhbHVlKSwgMzIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICgoMCwgdXRpbHNfMi5pc1N0cmljdEhleFN0cmluZykodmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gKDAsIHV0aWxzXzEucGFkU3RhcnQpKCgwLCB1dGlsc18yLmhleFRvQnl0ZXMpKHZhbHVlKS5zdWJhcnJheSgwLCAzMiksIDMyKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7XG4gICAgICAgICAgICByZXR1cm4gKDAsIHV0aWxzXzEucGFkU3RhcnQpKHZhbHVlLnN1YmFycmF5KDAsIDMyKSwgMzIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9KTtcbn1cbi8qKlxuICogRm9yIHNvbWUgcmVhc29uIGBldGhlcmV1bWpzLWFiaWAgdHJlYXRzIGBpbnROYCBhbmQgYGludE5bXWAgZGlmZmVyZW50bHlcbiAqIHNvIHdlIG5lZWQgdG8gbm9ybWFsaXplIGBpbnROW11gIGRpZmZlcmVudGx5LlxuICpcbiAqIEBwYXJhbSB0eXBlIC0gVGhlIHR5cGUgb2YgdGhlIHZhbHVlIHRvIG5vcm1hbGl6ZS5cbiAqIEBwYXJhbSB2YWx1ZXMgLSBUaGUgdmFsdWVzIHRvIG5vcm1hbGl6ZS5cbiAqIEByZXR1cm5zIFRoZSBub3JtYWxpemVkIHZhbHVlcy5cbiAqL1xuZnVuY3Rpb24gbm9ybWFsaXplSW50ZWdlcnModHlwZSwgdmFsdWVzKSB7XG4gICAgcmV0dXJuIHZhbHVlcy5tYXAoKHZhbHVlKSA9PiB7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnIHx8XG4gICAgICAgICAgICB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInIHx8XG4gICAgICAgICAgICB0eXBlb2YgdmFsdWUgPT09ICdiaWdpbnQnKSB7XG4gICAgICAgICAgICBjb25zdCBiaWdJbnRWYWx1ZSA9IHBhcnNlTnVtYmVyKHR5cGUsIHZhbHVlKTtcbiAgICAgICAgICAgIGlmIChiaWdJbnRWYWx1ZSA+PSBCaWdJbnQoMCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKDAsIHV0aWxzXzEucGFkU3RhcnQpKCgwLCB1dGlsc18yLmJpZ0ludFRvQnl0ZXMpKGJpZ0ludFZhbHVlKSwgMzIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbGVuZ3RoID0gKDAsIHBhcnNlcnNfMS5nZXRMZW5ndGgpKHR5cGUpO1xuICAgICAgICAgICAgY29uc3QgYXNJbnROID0gQmlnSW50LmFzSW50TihsZW5ndGgsIGJpZ0ludFZhbHVlKTtcbiAgICAgICAgICAgIHJldHVybiAoMCwgdXRpbHNfMi5zaWduZWRCaWdJbnRUb0J5dGVzKShhc0ludE4sIDMyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfSk7XG59XG4vKipcbiAqIEdlbmVyYXRlIHRoZSBcIlYxXCIgaGFzaCBmb3IgdGhlIHByb3ZpZGVkIHR5cGVkIG1lc3NhZ2UuXG4gKlxuICogVGhlIGhhc2ggd2lsbCBiZSBnZW5lcmF0ZWQgaW4gYWNjb3JkYW5jZSB3aXRoIGFuIGVhcmxpZXIgdmVyc2lvbiBvZiB0aGUgRUlQLTcxMlxuICogc3BlY2lmaWNhdGlvbi4gVGhpcyBoYXNoIGlzIHVzZWQgaW4gYHNpZ25UeXBlZERhdGFfdjFgLlxuICpcbiAqIEBwYXJhbSB0eXBlZERhdGEgLSBUaGUgdHlwZWQgbWVzc2FnZS5cbiAqIEByZXR1cm5zIFRoZSBoYXNoIHJlcHJlc2VudGluZyB0aGUgdHlwZSBvZiB0aGUgcHJvdmlkZWQgbWVzc2FnZS5cbiAqL1xuZnVuY3Rpb24gX3R5cGVkU2lnbmF0dXJlSGFzaCh0eXBlZERhdGEpIHtcbiAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcignRXhwZWN0IGFyZ3VtZW50IHRvIGJlIG5vbi1lbXB0eSBhcnJheScpO1xuICAgIGlmICh0eXBlb2YgdHlwZWREYXRhICE9PSAnb2JqZWN0JyB8fFxuICAgICAgICAhKCdsZW5ndGgnIGluIHR5cGVkRGF0YSkgfHxcbiAgICAgICAgIXR5cGVkRGF0YS5sZW5ndGgpIHtcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICAgIGNvbnN0IG5vcm1hbGl6ZWREYXRhID0gdHlwZWREYXRhLm1hcCgoeyBuYW1lLCB0eXBlLCB2YWx1ZSB9KSA9PiB7XG4gICAgICAgIC8vIEhhbmRsZSBhbiBlZGdlIGNhc2Ugd2l0aCBgYWRkcmVzc1tdYCB0eXBlcy5cbiAgICAgICAgaWYgKHR5cGUgPT09ICdhZGRyZXNzW10nKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICAgICAgdHlwZTogJ2J5dGVzMzJbXScsXG4gICAgICAgICAgICAgICAgdmFsdWU6IG5vcm1hbGl6ZUFkZHJlc3Nlcyh2YWx1ZSksXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIC8vIEhhbmRsZSBhbiBlZGdlIGNhc2Ugd2l0aCBgaW50TltdYCB0eXBlcy5cbiAgICAgICAgaWYgKHR5cGUuc3RhcnRzV2l0aCgnaW50JykgJiYgKDAsIHBhcnNlcnNfMS5pc0FycmF5VHlwZSkodHlwZSkpIHtcbiAgICAgICAgICAgIGNvbnN0IFtpbm5lclR5cGUsIGxlbmd0aF0gPSAoMCwgcGFyc2Vyc18xLmdldEFycmF5VHlwZSkodHlwZSk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICAgICAgdHlwZTogYGJ5dGVzMzJbJHtsZW5ndGggIT09IG51bGwgJiYgbGVuZ3RoICE9PSB2b2lkIDAgPyBsZW5ndGggOiAnJ31dYCxcbiAgICAgICAgICAgICAgICB2YWx1ZTogbm9ybWFsaXplSW50ZWdlcnMoaW5uZXJUeXBlLCB2YWx1ZSksXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgdHlwZSxcbiAgICAgICAgICAgIHZhbHVlOiBub3JtYWxpemVWYWx1ZSh0eXBlLCB2YWx1ZSksXG4gICAgICAgIH07XG4gICAgfSk7XG4gICAgY29uc3QgZGF0YSA9IG5vcm1hbGl6ZWREYXRhLm1hcCgoZSkgPT4ge1xuICAgICAgICBpZiAoZS50eXBlICE9PSAnYnl0ZXMnKSB7XG4gICAgICAgICAgICByZXR1cm4gZS52YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKDAsIHV0aWxzXzMubGVnYWN5VG9CdWZmZXIpKGUudmFsdWUpO1xuICAgIH0pO1xuICAgIGNvbnN0IHR5cGVzID0gbm9ybWFsaXplZERhdGEubWFwKChlKSA9PiB7XG4gICAgICAgIGlmIChlLnR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5zdXBwb3J0ZWQgb3IgaW52YWxpZCB0eXBlOiBcImZ1bmN0aW9uXCInKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZS50eXBlO1xuICAgIH0pO1xuICAgIGNvbnN0IHNjaGVtYSA9IHR5cGVkRGF0YS5tYXAoKGUpID0+IHtcbiAgICAgICAgaWYgKCFlLm5hbWUpIHtcbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBgJHtlLnR5cGV9ICR7ZS5uYW1lfWA7XG4gICAgfSk7XG4gICAgcmV0dXJuICgwLCB1dGlsXzEuYXJyVG9CdWZBcnIpKCgwLCBrZWNjYWtfMS5rZWNjYWsyNTYpKCgwLCBhYmlfdXRpbHNfMS5lbmNvZGVQYWNrZWQpKFsnYnl0ZXMzMicsICdieXRlczMyJ10sIFtcbiAgICAgICAgKDAsIGtlY2Nha18xLmtlY2NhazI1NikoKDAsIGFiaV91dGlsc18xLmVuY29kZVBhY2tlZCkoWydzdHJpbmdbXSddLCBbc2NoZW1hXSwgdHJ1ZSkpLFxuICAgICAgICAoMCwga2VjY2FrXzEua2VjY2FrMjU2KSgoMCwgYWJpX3V0aWxzXzEuZW5jb2RlUGFja2VkKSh0eXBlcywgZGF0YSwgdHJ1ZSkpLFxuICAgIF0pKSk7XG59XG4vKipcbiAqIFNpZ24gdHlwZWQgZGF0YSBhY2NvcmRpbmcgdG8gRUlQLTcxMi4gVGhlIHNpZ25pbmcgZGlmZmVycyBiYXNlZCB1cG9uIHRoZSBgdmVyc2lvbmAuXG4gKlxuICogVjEgaXMgYmFzZWQgdXBvbiBbYW4gZWFybHkgdmVyc2lvbiBvZlxuICogRUlQLTcxMl0oaHR0cHM6Ly9naXRodWIuY29tL2V0aGVyZXVtL0VJUHMvcHVsbC83MTIvY29tbWl0cy8yMWFiZTI1NGZlMDQ1MmQ4NTgzZDViMTMyYjFkN2JlODdjMDQzOWNhKVxuICogdGhhdCBsYWNrZWQgc29tZSBsYXRlciBzZWN1cml0eSBpbXByb3ZlbWVudHMsIGFuZCBzaG91bGQgZ2VuZXJhbGx5IGJlIG5lZ2xlY3RlZCBpbiBmYXZvciBvZlxuICogbGF0ZXIgdmVyc2lvbnMuXG4gKlxuICogVjMgaXMgYmFzZWQgb24gW0VJUC03MTJdKGh0dHBzOi8vZWlwcy5ldGhlcmV1bS5vcmcvRUlQUy9laXAtNzEyKSwgZXhjZXB0IHRoYXQgYXJyYXlzIGFuZFxuICogcmVjdXJzaXZlIGRhdGEgc3RydWN0dXJlcyBhcmUgbm90IHN1cHBvcnRlZC5cbiAqXG4gKiBWNCBpcyBiYXNlZCBvbiBbRUlQLTcxMl0oaHR0cHM6Ly9laXBzLmV0aGVyZXVtLm9yZy9FSVBTL2VpcC03MTIpLCBhbmQgaW5jbHVkZXMgZnVsbCBzdXBwb3J0IG9mXG4gKiBhcnJheXMgYW5kIHJlY3Vyc2l2ZSBkYXRhIHN0cnVjdHVyZXMuXG4gKlxuICogQHBhcmFtIG9wdGlvbnMgLSBUaGUgc2lnbmluZyBvcHRpb25zLlxuICogQHBhcmFtIG9wdGlvbnMucHJpdmF0ZUtleSAtIFRoZSBwcml2YXRlIGtleSB0byBzaWduIHdpdGguXG4gKiBAcGFyYW0gb3B0aW9ucy5kYXRhIC0gVGhlIHR5cGVkIGRhdGEgdG8gc2lnbi5cbiAqIEBwYXJhbSBvcHRpb25zLnZlcnNpb24gLSBUaGUgc2lnbmluZyB2ZXJzaW9uIHRvIHVzZS5cbiAqIEByZXR1cm5zIFRoZSAnMHgnLXByZWZpeGVkIGhleCBlbmNvZGVkIHNpZ25hdHVyZS5cbiAqL1xuZnVuY3Rpb24gc2lnblR5cGVkRGF0YSh7IHByaXZhdGVLZXksIGRhdGEsIHZlcnNpb24sIH0pIHtcbiAgICB2YWxpZGF0ZVZlcnNpb24odmVyc2lvbik7XG4gICAgaWYgKCgwLCB1dGlsc18zLmlzTnVsbGlzaCkoZGF0YSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNaXNzaW5nIGRhdGEgcGFyYW1ldGVyJyk7XG4gICAgfVxuICAgIGVsc2UgaWYgKCgwLCB1dGlsc18zLmlzTnVsbGlzaCkocHJpdmF0ZUtleSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNaXNzaW5nIHByaXZhdGUga2V5IHBhcmFtZXRlcicpO1xuICAgIH1cbiAgICBjb25zdCBtZXNzYWdlSGFzaCA9IHZlcnNpb24gPT09IFNpZ25UeXBlZERhdGFWZXJzaW9uLlYxXG4gICAgICAgID8gX3R5cGVkU2lnbmF0dXJlSGFzaChkYXRhKVxuICAgICAgICA6IGV4cG9ydHMuVHlwZWREYXRhVXRpbHMuZWlwNzEySGFzaChkYXRhLCB2ZXJzaW9uKTtcbiAgICBjb25zdCBzaWcgPSAoMCwgdXRpbF8xLmVjc2lnbikobWVzc2FnZUhhc2gsIHByaXZhdGVLZXkpO1xuICAgIHJldHVybiAoMCwgdXRpbHNfMy5jb25jYXRTaWcpKCgwLCB1dGlsXzEuYXJyVG9CdWZBcnIpKCgwLCB1dGlsc18yLmJpZ0ludFRvQnl0ZXMpKHNpZy52KSksIHNpZy5yLCBzaWcucyk7XG59XG5leHBvcnRzLnNpZ25UeXBlZERhdGEgPSBzaWduVHlwZWREYXRhO1xuLyoqXG4gKiBSZWNvdmVyIHRoZSBhZGRyZXNzIG9mIHRoZSBhY2NvdW50IHRoYXQgY3JlYXRlZCB0aGUgZ2l2ZW4gRUlQLTcxMlxuICogc2lnbmF0dXJlLiBUaGUgdmVyc2lvbiBwcm92aWRlZCBtdXN0IG1hdGNoIHRoZSB2ZXJzaW9uIHVzZWQgdG9cbiAqIGNyZWF0ZSB0aGUgc2lnbmF0dXJlLlxuICpcbiAqIEBwYXJhbSBvcHRpb25zIC0gVGhlIHNpZ25hdHVyZSByZWNvdmVyeSBvcHRpb25zLlxuICogQHBhcmFtIG9wdGlvbnMuZGF0YSAtIFRoZSB0eXBlZCBkYXRhIHRoYXQgd2FzIHNpZ25lZC5cbiAqIEBwYXJhbSBvcHRpb25zLnNpZ25hdHVyZSAtIFRoZSAnMHgtcHJlZml4ZWQgaGV4IGVuY29kZWQgbWVzc2FnZSBzaWduYXR1cmUuXG4gKiBAcGFyYW0gb3B0aW9ucy52ZXJzaW9uIC0gVGhlIHNpZ25pbmcgdmVyc2lvbiB0byB1c2UuXG4gKiBAcmV0dXJucyBUaGUgJzB4Jy1wcmVmaXhlZCBoZXggYWRkcmVzcyBvZiB0aGUgc2lnbmVyLlxuICovXG5mdW5jdGlvbiByZWNvdmVyVHlwZWRTaWduYXR1cmUoeyBkYXRhLCBzaWduYXR1cmUsIHZlcnNpb24sIH0pIHtcbiAgICB2YWxpZGF0ZVZlcnNpb24odmVyc2lvbik7XG4gICAgaWYgKCgwLCB1dGlsc18zLmlzTnVsbGlzaCkoZGF0YSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNaXNzaW5nIGRhdGEgcGFyYW1ldGVyJyk7XG4gICAgfVxuICAgIGVsc2UgaWYgKCgwLCB1dGlsc18zLmlzTnVsbGlzaCkoc2lnbmF0dXJlKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01pc3Npbmcgc2lnbmF0dXJlIHBhcmFtZXRlcicpO1xuICAgIH1cbiAgICBjb25zdCBtZXNzYWdlSGFzaCA9IHZlcnNpb24gPT09IFNpZ25UeXBlZERhdGFWZXJzaW9uLlYxXG4gICAgICAgID8gX3R5cGVkU2lnbmF0dXJlSGFzaChkYXRhKVxuICAgICAgICA6IGV4cG9ydHMuVHlwZWREYXRhVXRpbHMuZWlwNzEySGFzaChkYXRhLCB2ZXJzaW9uKTtcbiAgICBjb25zdCBwdWJsaWNLZXkgPSAoMCwgdXRpbHNfMy5yZWNvdmVyUHVibGljS2V5KShtZXNzYWdlSGFzaCwgc2lnbmF0dXJlKTtcbiAgICBjb25zdCBzZW5kZXIgPSAoMCwgdXRpbF8xLnB1YmxpY1RvQWRkcmVzcykocHVibGljS2V5KTtcbiAgICByZXR1cm4gKDAsIHV0aWxzXzIuYnl0ZXNUb0hleCkoc2VuZGVyKTtcbn1cbmV4cG9ydHMucmVjb3ZlclR5cGVkU2lnbmF0dXJlID0gcmVjb3ZlclR5cGVkU2lnbmF0dXJlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2lnbi10eXBlZC1kYXRhLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/.pnpm/@metamask+eth-sig-util@7.0.2/node_modules/@metamask/eth-sig-util/dist/sign-typed-data.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/.pnpm/@metamask+eth-sig-util@7.0.2/node_modules/@metamask/eth-sig-util/dist/utils.js":
/*!***************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/@metamask+eth-sig-util@7.0.2/node_modules/@metamask/eth-sig-util/dist/utils.js ***!
  \***************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.normalize = exports.recoverPublicKey = exports.concatSig = exports.legacyToBuffer = exports.isNullish = exports.padWithZeroes = void 0;\nconst util_1 = __webpack_require__(/*! @ethereumjs/util */ \"(ssr)/../../node_modules/.pnpm/@ethereumjs+util@8.1.0/node_modules/@ethereumjs/util/dist/index.js\");\nconst utils_1 = __webpack_require__(/*! @metamask/utils */ \"(ssr)/../../node_modules/.pnpm/@metamask+utils@8.5.0/node_modules/@metamask/utils/dist/index.cjs\");\n/**\n * Pads the front of the given hex string with zeroes until it reaches the\n * target length. If the input string is already longer than or equal to the\n * target length, it is returned unmodified.\n *\n * If the input string is \"0x\"-prefixed or not a hex string, an error will be\n * thrown.\n *\n * @param hexString - The hexadecimal string to pad with zeroes.\n * @param targetLength - The target length of the hexadecimal string.\n * @returns The input string front-padded with zeroes, or the original string\n * if it was already greater than or equal to to the target length.\n */\nfunction padWithZeroes(hexString, targetLength) {\n    if (hexString !== '' && !/^[a-f0-9]+$/iu.test(hexString)) {\n        throw new Error(`Expected an unprefixed hex string. Received: ${hexString}`);\n    }\n    if (targetLength < 0) {\n        throw new Error(`Expected a non-negative integer target length. Received: ${targetLength}`);\n    }\n    return String.prototype.padStart.call(hexString, targetLength, '0');\n}\nexports.padWithZeroes = padWithZeroes;\n/**\n * Returns `true` if the given value is nullish.\n *\n * @param value - The value being checked.\n * @returns Whether the value is nullish.\n */\nfunction isNullish(value) {\n    return value === null || value === undefined;\n}\nexports.isNullish = isNullish;\n/**\n * Convert a value to a Buffer. This function should be equivalent to the `toBuffer` function in\n * `ethereumjs-util@5.2.1`.\n *\n * @param value - The value to convert to a Buffer.\n * @returns The given value as a Buffer.\n */\nfunction legacyToBuffer(value) {\n    return typeof value === 'string' && !(0, util_1.isHexString)(value)\n        ? Buffer.from(value)\n        : (0, util_1.toBuffer)(value);\n}\nexports.legacyToBuffer = legacyToBuffer;\n/**\n * Concatenate an extended ECDSA signature into a single '0x'-prefixed hex string.\n *\n * @param v - The 'v' portion of the signature.\n * @param r - The 'r' portion of the signature.\n * @param s - The 's' portion of the signature.\n * @returns The concatenated ECDSA signature as a '0x'-prefixed string.\n */\nfunction concatSig(v, r, s) {\n    const rSig = (0, util_1.fromSigned)(r);\n    const sSig = (0, util_1.fromSigned)(s);\n    const vSig = (0, util_1.bufferToInt)(v);\n    const rStr = padWithZeroes((0, util_1.toUnsigned)(rSig).toString('hex'), 64);\n    const sStr = padWithZeroes((0, util_1.toUnsigned)(sSig).toString('hex'), 64);\n    const vStr = (0, utils_1.remove0x)((0, utils_1.numberToHex)(vSig));\n    return (0, utils_1.add0x)(rStr.concat(sStr, vStr));\n}\nexports.concatSig = concatSig;\n/**\n * Recover the public key from the given signature and message hash.\n *\n * @param messageHash - The hash of the signed message.\n * @param signature - The signature.\n * @returns The public key of the signer.\n */\nfunction recoverPublicKey(messageHash, signature) {\n    const sigParams = (0, util_1.fromRpcSig)(signature);\n    return (0, util_1.ecrecover)(messageHash, sigParams.v, sigParams.r, sigParams.s);\n}\nexports.recoverPublicKey = recoverPublicKey;\n/**\n * Normalize the input to a lower-cased '0x'-prefixed hex string.\n *\n * @param input - The value to normalize.\n * @returns The normalized value.\n */\nfunction normalize(input) {\n    if (isNullish(input)) {\n        return undefined;\n    }\n    if (typeof input === 'number') {\n        if (input < 0) {\n            return '0x';\n        }\n        const buffer = (0, utils_1.numberToBytes)(input);\n        input = (0, utils_1.bytesToHex)(buffer);\n    }\n    if (typeof input !== 'string') {\n        let msg = 'eth-sig-util.normalize() requires hex string or integer input.';\n        msg += ` received ${typeof input}: ${input}`;\n        throw new Error(msg);\n    }\n    return (0, utils_1.add0x)(input.toLowerCase());\n}\nexports.normalize = normalize;\n//# sourceMappingURL=utils.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BtZXRhbWFzaytldGgtc2lnLXV0aWxANy4wLjIvbm9kZV9tb2R1bGVzL0BtZXRhbWFzay9ldGgtc2lnLXV0aWwvZGlzdC91dGlscy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxpQkFBaUIsR0FBRyx3QkFBd0IsR0FBRyxpQkFBaUIsR0FBRyxzQkFBc0IsR0FBRyxpQkFBaUIsR0FBRyxxQkFBcUI7QUFDckksZUFBZSxtQkFBTyxDQUFDLDJIQUFrQjtBQUN6QyxnQkFBZ0IsbUJBQU8sQ0FBQyx5SEFBaUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0VBQXdFLFVBQVU7QUFDbEY7QUFDQTtBQUNBLG9GQUFvRixhQUFhO0FBQ2pHO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixhQUFhLElBQUksTUFBTTtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQiIsInNvdXJjZXMiOlsid2VicGFjazovL0Bjb2xsZWN0aWJsZS93ZWIvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BtZXRhbWFzaytldGgtc2lnLXV0aWxANy4wLjIvbm9kZV9tb2R1bGVzL0BtZXRhbWFzay9ldGgtc2lnLXV0aWwvZGlzdC91dGlscy5qcz8zMDE5Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5ub3JtYWxpemUgPSBleHBvcnRzLnJlY292ZXJQdWJsaWNLZXkgPSBleHBvcnRzLmNvbmNhdFNpZyA9IGV4cG9ydHMubGVnYWN5VG9CdWZmZXIgPSBleHBvcnRzLmlzTnVsbGlzaCA9IGV4cG9ydHMucGFkV2l0aFplcm9lcyA9IHZvaWQgMDtcbmNvbnN0IHV0aWxfMSA9IHJlcXVpcmUoXCJAZXRoZXJldW1qcy91dGlsXCIpO1xuY29uc3QgdXRpbHNfMSA9IHJlcXVpcmUoXCJAbWV0YW1hc2svdXRpbHNcIik7XG4vKipcbiAqIFBhZHMgdGhlIGZyb250IG9mIHRoZSBnaXZlbiBoZXggc3RyaW5nIHdpdGggemVyb2VzIHVudGlsIGl0IHJlYWNoZXMgdGhlXG4gKiB0YXJnZXQgbGVuZ3RoLiBJZiB0aGUgaW5wdXQgc3RyaW5nIGlzIGFscmVhZHkgbG9uZ2VyIHRoYW4gb3IgZXF1YWwgdG8gdGhlXG4gKiB0YXJnZXQgbGVuZ3RoLCBpdCBpcyByZXR1cm5lZCB1bm1vZGlmaWVkLlxuICpcbiAqIElmIHRoZSBpbnB1dCBzdHJpbmcgaXMgXCIweFwiLXByZWZpeGVkIG9yIG5vdCBhIGhleCBzdHJpbmcsIGFuIGVycm9yIHdpbGwgYmVcbiAqIHRocm93bi5cbiAqXG4gKiBAcGFyYW0gaGV4U3RyaW5nIC0gVGhlIGhleGFkZWNpbWFsIHN0cmluZyB0byBwYWQgd2l0aCB6ZXJvZXMuXG4gKiBAcGFyYW0gdGFyZ2V0TGVuZ3RoIC0gVGhlIHRhcmdldCBsZW5ndGggb2YgdGhlIGhleGFkZWNpbWFsIHN0cmluZy5cbiAqIEByZXR1cm5zIFRoZSBpbnB1dCBzdHJpbmcgZnJvbnQtcGFkZGVkIHdpdGggemVyb2VzLCBvciB0aGUgb3JpZ2luYWwgc3RyaW5nXG4gKiBpZiBpdCB3YXMgYWxyZWFkeSBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gdG8gdGhlIHRhcmdldCBsZW5ndGguXG4gKi9cbmZ1bmN0aW9uIHBhZFdpdGhaZXJvZXMoaGV4U3RyaW5nLCB0YXJnZXRMZW5ndGgpIHtcbiAgICBpZiAoaGV4U3RyaW5nICE9PSAnJyAmJiAhL15bYS1mMC05XSskL2l1LnRlc3QoaGV4U3RyaW5nKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEV4cGVjdGVkIGFuIHVucHJlZml4ZWQgaGV4IHN0cmluZy4gUmVjZWl2ZWQ6ICR7aGV4U3RyaW5nfWApO1xuICAgIH1cbiAgICBpZiAodGFyZ2V0TGVuZ3RoIDwgMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEV4cGVjdGVkIGEgbm9uLW5lZ2F0aXZlIGludGVnZXIgdGFyZ2V0IGxlbmd0aC4gUmVjZWl2ZWQ6ICR7dGFyZ2V0TGVuZ3RofWApO1xuICAgIH1cbiAgICByZXR1cm4gU3RyaW5nLnByb3RvdHlwZS5wYWRTdGFydC5jYWxsKGhleFN0cmluZywgdGFyZ2V0TGVuZ3RoLCAnMCcpO1xufVxuZXhwb3J0cy5wYWRXaXRoWmVyb2VzID0gcGFkV2l0aFplcm9lcztcbi8qKlxuICogUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGdpdmVuIHZhbHVlIGlzIG51bGxpc2guXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIGJlaW5nIGNoZWNrZWQuXG4gKiBAcmV0dXJucyBXaGV0aGVyIHRoZSB2YWx1ZSBpcyBudWxsaXNoLlxuICovXG5mdW5jdGlvbiBpc051bGxpc2godmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHVuZGVmaW5lZDtcbn1cbmV4cG9ydHMuaXNOdWxsaXNoID0gaXNOdWxsaXNoO1xuLyoqXG4gKiBDb252ZXJ0IGEgdmFsdWUgdG8gYSBCdWZmZXIuIFRoaXMgZnVuY3Rpb24gc2hvdWxkIGJlIGVxdWl2YWxlbnQgdG8gdGhlIGB0b0J1ZmZlcmAgZnVuY3Rpb24gaW5cbiAqIGBldGhlcmV1bWpzLXV0aWxANS4yLjFgLlxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBjb252ZXJ0IHRvIGEgQnVmZmVyLlxuICogQHJldHVybnMgVGhlIGdpdmVuIHZhbHVlIGFzIGEgQnVmZmVyLlxuICovXG5mdW5jdGlvbiBsZWdhY3lUb0J1ZmZlcih2YWx1ZSkge1xuICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnICYmICEoMCwgdXRpbF8xLmlzSGV4U3RyaW5nKSh2YWx1ZSlcbiAgICAgICAgPyBCdWZmZXIuZnJvbSh2YWx1ZSlcbiAgICAgICAgOiAoMCwgdXRpbF8xLnRvQnVmZmVyKSh2YWx1ZSk7XG59XG5leHBvcnRzLmxlZ2FjeVRvQnVmZmVyID0gbGVnYWN5VG9CdWZmZXI7XG4vKipcbiAqIENvbmNhdGVuYXRlIGFuIGV4dGVuZGVkIEVDRFNBIHNpZ25hdHVyZSBpbnRvIGEgc2luZ2xlICcweCctcHJlZml4ZWQgaGV4IHN0cmluZy5cbiAqXG4gKiBAcGFyYW0gdiAtIFRoZSAndicgcG9ydGlvbiBvZiB0aGUgc2lnbmF0dXJlLlxuICogQHBhcmFtIHIgLSBUaGUgJ3InIHBvcnRpb24gb2YgdGhlIHNpZ25hdHVyZS5cbiAqIEBwYXJhbSBzIC0gVGhlICdzJyBwb3J0aW9uIG9mIHRoZSBzaWduYXR1cmUuXG4gKiBAcmV0dXJucyBUaGUgY29uY2F0ZW5hdGVkIEVDRFNBIHNpZ25hdHVyZSBhcyBhICcweCctcHJlZml4ZWQgc3RyaW5nLlxuICovXG5mdW5jdGlvbiBjb25jYXRTaWcodiwgciwgcykge1xuICAgIGNvbnN0IHJTaWcgPSAoMCwgdXRpbF8xLmZyb21TaWduZWQpKHIpO1xuICAgIGNvbnN0IHNTaWcgPSAoMCwgdXRpbF8xLmZyb21TaWduZWQpKHMpO1xuICAgIGNvbnN0IHZTaWcgPSAoMCwgdXRpbF8xLmJ1ZmZlclRvSW50KSh2KTtcbiAgICBjb25zdCByU3RyID0gcGFkV2l0aFplcm9lcygoMCwgdXRpbF8xLnRvVW5zaWduZWQpKHJTaWcpLnRvU3RyaW5nKCdoZXgnKSwgNjQpO1xuICAgIGNvbnN0IHNTdHIgPSBwYWRXaXRoWmVyb2VzKCgwLCB1dGlsXzEudG9VbnNpZ25lZCkoc1NpZykudG9TdHJpbmcoJ2hleCcpLCA2NCk7XG4gICAgY29uc3QgdlN0ciA9ICgwLCB1dGlsc18xLnJlbW92ZTB4KSgoMCwgdXRpbHNfMS5udW1iZXJUb0hleCkodlNpZykpO1xuICAgIHJldHVybiAoMCwgdXRpbHNfMS5hZGQweCkoclN0ci5jb25jYXQoc1N0ciwgdlN0cikpO1xufVxuZXhwb3J0cy5jb25jYXRTaWcgPSBjb25jYXRTaWc7XG4vKipcbiAqIFJlY292ZXIgdGhlIHB1YmxpYyBrZXkgZnJvbSB0aGUgZ2l2ZW4gc2lnbmF0dXJlIGFuZCBtZXNzYWdlIGhhc2guXG4gKlxuICogQHBhcmFtIG1lc3NhZ2VIYXNoIC0gVGhlIGhhc2ggb2YgdGhlIHNpZ25lZCBtZXNzYWdlLlxuICogQHBhcmFtIHNpZ25hdHVyZSAtIFRoZSBzaWduYXR1cmUuXG4gKiBAcmV0dXJucyBUaGUgcHVibGljIGtleSBvZiB0aGUgc2lnbmVyLlxuICovXG5mdW5jdGlvbiByZWNvdmVyUHVibGljS2V5KG1lc3NhZ2VIYXNoLCBzaWduYXR1cmUpIHtcbiAgICBjb25zdCBzaWdQYXJhbXMgPSAoMCwgdXRpbF8xLmZyb21ScGNTaWcpKHNpZ25hdHVyZSk7XG4gICAgcmV0dXJuICgwLCB1dGlsXzEuZWNyZWNvdmVyKShtZXNzYWdlSGFzaCwgc2lnUGFyYW1zLnYsIHNpZ1BhcmFtcy5yLCBzaWdQYXJhbXMucyk7XG59XG5leHBvcnRzLnJlY292ZXJQdWJsaWNLZXkgPSByZWNvdmVyUHVibGljS2V5O1xuLyoqXG4gKiBOb3JtYWxpemUgdGhlIGlucHV0IHRvIGEgbG93ZXItY2FzZWQgJzB4Jy1wcmVmaXhlZCBoZXggc3RyaW5nLlxuICpcbiAqIEBwYXJhbSBpbnB1dCAtIFRoZSB2YWx1ZSB0byBub3JtYWxpemUuXG4gKiBAcmV0dXJucyBUaGUgbm9ybWFsaXplZCB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gbm9ybWFsaXplKGlucHV0KSB7XG4gICAgaWYgKGlzTnVsbGlzaChpbnB1dCkpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgaWYgKGlucHV0IDwgMCkge1xuICAgICAgICAgICAgcmV0dXJuICcweCc7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYnVmZmVyID0gKDAsIHV0aWxzXzEubnVtYmVyVG9CeXRlcykoaW5wdXQpO1xuICAgICAgICBpbnB1dCA9ICgwLCB1dGlsc18xLmJ5dGVzVG9IZXgpKGJ1ZmZlcik7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgaW5wdXQgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGxldCBtc2cgPSAnZXRoLXNpZy11dGlsLm5vcm1hbGl6ZSgpIHJlcXVpcmVzIGhleCBzdHJpbmcgb3IgaW50ZWdlciBpbnB1dC4nO1xuICAgICAgICBtc2cgKz0gYCByZWNlaXZlZCAke3R5cGVvZiBpbnB1dH06ICR7aW5wdXR9YDtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG4gICAgfVxuICAgIHJldHVybiAoMCwgdXRpbHNfMS5hZGQweCkoaW5wdXQudG9Mb3dlckNhc2UoKSk7XG59XG5leHBvcnRzLm5vcm1hbGl6ZSA9IG5vcm1hbGl6ZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXV0aWxzLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/.pnpm/@metamask+eth-sig-util@7.0.2/node_modules/@metamask/eth-sig-util/dist/utils.js\n");

/***/ })

};
;